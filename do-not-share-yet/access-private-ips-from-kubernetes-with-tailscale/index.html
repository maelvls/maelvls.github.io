<!DOCTYPE html>
<html lang="en"><head>

  <meta name="generator" content="Hugo 0.147.6">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Ma√´l Valais"><meta name="description" content=""><meta property="og:url" content="https://maelvls.dev/do-not-share-yet/access-private-ips-from-kubernetes-with-tailscale/">
  <meta property="og:site_name" content="maelvls dev blog">
  <meta property="og:title" content="Access Private IPs From Kubernetes With Tailscale">
  <meta property="og:description" content="Access Private IPs From Kubernetes With Tailscale I want to give all my Kubernetes pods access to my PC that is on a private network. The plan is to use a GCP VM as a ‚Äúrelay‚Äù where Tailscale is running and configure the VPC to forward traffic to the relay.
Machine GCP IPs Tailscale IPs aorus (my PC) 100.127.221.57 relay 10.132.0.16 100.82.245.178 test 10.132.0.17 The first step is to get an ephemeral token on Tailscale:">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="2021">
    <meta property="article:published_time" content="2021-10-30T14:53:37+02:00">
    <meta property="article:modified_time" content="2021-10-30T14:53:37+02:00">
    <meta property="og:image" content="https://maelvls.dev/do-not-share-yet/access-private-ips-from-kubernetes-with-tailscale/cover-access-private-ips-from-kubernetes-with-tailscale.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://maelvls.dev/do-not-share-yet/access-private-ips-from-kubernetes-with-tailscale/cover-access-private-ips-from-kubernetes-with-tailscale.png">
  <meta name="twitter:title" content="Access Private IPs From Kubernetes With Tailscale">
  <meta name="twitter:description" content="Access Private IPs From Kubernetes With Tailscale I want to give all my Kubernetes pods access to my PC that is on a private network. The plan is to use a GCP VM as a ‚Äúrelay‚Äù where Tailscale is running and configure the VPC to forward traffic to the relay.
Machine GCP IPs Tailscale IPs aorus (my PC) 100.127.221.57 relay 10.132.0.16 100.82.245.178 test 10.132.0.17 The first step is to get an ephemeral token on Tailscale:">
<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
  <link rel="stylesheet" type="text/css" media="screen" href="https://maelvls.dev/do-not-share-yet/css/normalize.css" />
  <link rel="stylesheet" type="text/css" media="screen" href="https://maelvls.dev/do-not-share-yet/css/main.css" />
  <link rel="stylesheet" type="text/css" media="screen" href="https://maelvls.dev/do-not-share-yet/css/all.css" />
<link rel="stylesheet" type="text/css" media="screen" href="https://maelvls.dev/do-not-share-yet/css/maelvls.css" /><title>Access Private IPs From Kubernetes With Tailscale | maelvls dev blog</title></head>
<body>

<header>

  <div id="avatar">
    <a href="https://maelvls.dev/do-not-share-yet/">
      <img src="/img/mael.jpg" alt="maelvls dev blog">
    </a>
  </div>

  <div id="titletext"><h2 id="title"><a href="https://maelvls.dev/do-not-share-yet/">maelvls dev blog</a></h2></div>
  <div id="title-description"><p id="subtitle">Systems software engineer. I write mostly about Kubernetes and Go. <a href="/about/">About</a></p><div id=social>
    <nav>
      <ul><li><a href="https://github.com/maelvls"><i title="Github" class="icons fab fa-github"></i></a></li><li><a href="https://x.com/maelvls"><i title="X" class="icons fab fa-x"></i></a></li><li><a href="https://dev.to/maelvls"><i title="Ma√´l Valais&#39;s DEV Community Profile" class="icons fab fa-dev"></i></a></li></ul>
    </nav>
  </div>
  </div>
  <div id="mainmenu">
	
  </div>
</header>
<main><div class="post">
    <div class="author">
        
    </div>
    <div class="post-header">
        
        <div class="meta">
            <div class="date">
                <span class="day">30</span>
                <span class="rest">
                    
                    Oct2021
                    
                </span>
            </div>
        </div>
        
        <div class="matter">
            <h1 class="title">Access Private IPs From Kubernetes With Tailscale</h1>
        </div>
        
    </div>
    <div class="markdown">
        <h1 id="access-private-ips-from-kubernetes-with-tailscale">Access Private IPs From Kubernetes With Tailscale</h1>
<p>I want to give all my Kubernetes pods access to my PC that is on a private network. The plan is to use a GCP VM as a &ldquo;relay&rdquo; where Tailscale is running and configure the VPC to forward traffic to the relay.</p>
<table>
  <thead>
      <tr>
          <th>Machine</th>
          <th>GCP IPs</th>
          <th>Tailscale IPs</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>aorus (my PC)</td>
          <td></td>
          <td>100.127.221.57</td>
      </tr>
      <tr>
          <td>relay</td>
          <td>10.132.0.16</td>
          <td>100.82.245.178</td>
      </tr>
      <tr>
          <td>test</td>
          <td>10.132.0.17</td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>The first step is to get an ephemeral token on Tailscale:</p>
<p><img src="tailscale-get-token.png" alt=""></p>
<p>Now, let us create the relay VM:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="nv">TOKEN</span><span class="o">=</span>...
</span></span><span class="line"><span class="cl">gcloud compute instances create relay --machine-type f1-micro --zone europe-west1-c <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --project jetstack-mael-valais --can-ip-forward <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --metadata<span class="o">=</span>startup-script<span class="o">=</span><span class="s2">&#34;sudo tee -a /etc/sysctl.conf &lt;&lt;&lt;</span>$<span class="s2">&#39;net.ipv4.ip_forward=1\nnet.ipv6.conf.all.forwarding=1&#39; &amp;&amp; tee .profile -a &lt;&lt;&lt;&#39;PATH=\$PATH:/sbin:/usr/sbin&#39; &amp;&amp; sudo update-alternatives --set iptables /usr/sbin/iptables-legacy &amp;&amp; curl -fsSL https://pkgs.tailscale.com/stable/ubuntu/focal.gpg | sudo apt-key add - &amp;&amp; curl -fsSL https://pkgs.tailscale.com/stable/ubuntu/focal.list | sudo tee /etc/apt/sources.list.d/tailscale.list &amp;&amp; sudo apt-get update &amp;&amp; sudo apt-get install tailscale &amp;&amp; sudo tailscale up --authkey </span><span class="nv">$TOKEN</span><span class="s2">&#34;</span>
</span></span></code></pre></div><blockquote>
<p>Note: the <code>update-alternatives</code> trick above is due to the fact that we are using Debian 10 that defaults <code>iptables</code> to its NF version. Here, we want to be using the legacy way.</p></blockquote>
<p>Now, let us make sure that all traffic that has the Tailscale IP as destination on my GCP project get routed to the relay VM:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">gcloud compute routes create tailscale --destination-range<span class="o">=</span>100.64.0.0/10 <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --next-hop-instance<span class="o">=</span>relay --project jetstack-mael-valais
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ gcloud compute ssh relay -- tailscale status
</span></span><span class="line"><span class="cl">100.82.245.178  hit-me               maelvls@     linux   -
</span></span><span class="line"><span class="cl">100.127.221.57  aorus                maelvls@     linux   idle, tx <span class="m">4396</span> rx <span class="m">3076</span>
</span></span></code></pre></div><p>At this point, I thought I was done, but I wasn&rsquo;t. I created a test VM on my
project to test the setup:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">gcloud compute instances create <span class="nb">test</span> --machine-type f1-micro --zone europe-west1-c --project jetstack-mael-valais
</span></span><span class="line"><span class="cl">gcloud compute ssh <span class="nb">test</span> -- sudo apt install netcat -y
</span></span></code></pre></div><p>It seems like my PC is not reachable from the test VM:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ gcloud compute ssh <span class="nb">test</span> -- nc -v 100.127.221.57 <span class="m">22</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>UNKNOWN<span class="o">)</span> <span class="o">[</span>100.127.221.57<span class="o">]</span> <span class="m">22</span> <span class="o">(</span>ssh<span class="o">)</span> : Connection timed out
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">gcloud compute ssh relay --command <span class="s2">&#34;sudo tcpdump -U -i tailscale0 -w -&#34;</span> <span class="p">|</span> wireshark -k -y RAW -i -
</span></span></code></pre></div><p><img src="wireshark-relay-tailscale0.png" alt=""></p>
<p>The packets seem to be sent correctly to my PC, but nothing is received. Let us see on my PC if anything gets received:</p>
<p><img src="wireshark-aorus-tailscale0.png" alt=""></p>
<p>No surprise, no packet is received. If we look closer to the packet that the relay is trying to send to my PC, we can see that the source address isn&rsquo;t routable from my PC:</p>
<p><img src="wireshark-relay-tailscale0-annotated.png" alt=""></p>
<p>My guess is that the relay VM was able to send its packet, but my PC wouldn&rsquo;t know how to send it back. I figured it needed changing the source IP:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># Won&#39;t be saved after a reboot of the VM!</span>
</span></span><span class="line"><span class="cl">gcloud compute ssh relay -- sudo iptables -t nat -A POSTROUTING -j SNAT --to-source 100.82.245.178
</span></span></code></pre></div><p>Retrying the test, it works:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ gcloud compute ssh <span class="nb">test</span> -- nc -v 100.127.221.57 <span class="m">22</span>
</span></span><span class="line"><span class="cl">100.127.221.57: inverse host lookup failed: Unknown host
</span></span><span class="line"><span class="cl"><span class="o">(</span>UNKNOWN<span class="o">)</span> <span class="o">[</span>100.127.221.57<span class="o">]</span> <span class="m">22</span> <span class="o">(</span>ssh<span class="o">)</span> open
</span></span><span class="line"><span class="cl">SSH-2.0-OpenSSH_8.4p1 Ubuntu-5ubuntu1.1
</span></span></code></pre></div><blockquote>
<p><strong>Note:</strong> In order to reset the in-memory iptables rules, you can run:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">sudo iptables -P INPUT ACCEPT
</span></span><span class="line"><span class="cl">sudo iptables -P OUTPUT ACCEPT
</span></span><span class="line"><span class="cl">sudo iptables -P FORWARD ACCEPT
</span></span><span class="line"><span class="cl">sudo iptables -F
</span></span><span class="line"><span class="cl">sudo iptables -X
</span></span><span class="line"><span class="cl">sudo iptables -t nat -F
</span></span><span class="line"><span class="cl">sudo iptables -t nat -X
</span></span><span class="line"><span class="cl">sudo iptables -t mangle -F
</span></span><span class="line"><span class="cl">sudo iptables -t mangle -X
</span></span></code></pre></div></blockquote>
<p>Let us see if we can reach my PC from a GKE cluster:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ gcloud container clusters create foo --project<span class="o">=</span>jetstack-mael-valais --zone<span class="o">=</span>europe-west2-b
</span></span><span class="line"><span class="cl">$ gcloud container clusters get-credentials foo --project<span class="o">=</span>jetstack-mael-valais --zone<span class="o">=</span>europe-west2-b
</span></span><span class="line"><span class="cl">$ kubectl run c -it --rm --restart<span class="o">=</span>Never -q --image<span class="o">=</span>nicolaka/netshoot
</span></span><span class="line"><span class="cl">% nc -v 100.127.221.57 <span class="m">22</span>
</span></span><span class="line"><span class="cl">Connection to 100.127.221.57 <span class="m">22</span> port <span class="o">[</span>tcp/ssh<span class="o">]</span> succeeded!
</span></span><span class="line"><span class="cl">SSH-2.0-OpenSSH_8.4p1 Ubuntu-5ubuntu1.1
</span></span></code></pre></div><p>Excellent!</p>
<h2 id="conclusion">Conclusion</h2>
<p>Although pods can access Tailscale IPs, it does not work with the MagicDNS feature. The only way (I mean, the only &ldquo;easy&rdquo; way) would be to have a container sidecar with <code>CAP_NET_ADMIN</code> with Tailscale running along with the pod that requires access to the Tailscale IPs.</p>

    </div>
    <a href="https://github.com/maelvls/maelvls.github.io/edit/source/content/2021/access-private-ips-from-kubernetes-with-tailscale/index.md">üìù Edit this page</a>
    <div class="tags">
        
        
        
        
        
        
        
        
        
    </div>

<script
  src="https://utteranc.es/client.js"
  repo="maelvls/maelvls.github.io"
  issue-term="pathname"
  label="üí¨"
  theme="github-light"
  crossorigin="anonymous"
  async
></script>
</div>

</main><footer>
    
</footer></body>
</html>
