<!DOCTYPE html>
<html lang="en"><head>

  <meta name="generator" content="Hugo 0.75.1" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Maël Valais"><meta name="keywords" content="kubernetes,kind,docker,networking,dns"><meta name="description" content="Kind offers an excellent UX to Kubernetes developers but lacks support for caching images; each time you recreate a new cluster, all the previous downloaded images are gone. In this post, I explain why the default Docker network is a trap and how to set up a registry &amp; make sure that it actually works."><meta property="og:title" content="Pull-through Docker registry on Kind clusters" />
<meta property="og:description" content="Kind offers an excellent UX to Kubernetes developers but lacks support for caching images; each time you recreate a new cluster, all the previous downloaded images are gone. In this post, I explain why the default Docker network is a trap and how to set up a registry &amp; make sure that it actually works." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://maelvls.dev/do-not-share-yet/docker-proxy-registry-kind/" />
<meta property="og:image" content="https://maelvls.dev/do-not-share-yet/docker-proxy-registry-kind/cover-docker-proxy-registry-kind.png" />
<meta property="article:published_time" content="2020-07-03T15:13:39+02:00" />
<meta property="article:modified_time" content="2020-07-03T15:13:39+02:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://maelvls.dev/do-not-share-yet/docker-proxy-registry-kind/cover-docker-proxy-registry-kind.png"/>

<meta name="twitter:title" content="Pull-through Docker registry on Kind clusters"/>
<meta name="twitter:description" content="Kind offers an excellent UX to Kubernetes developers but lacks support for caching images; each time you recreate a new cluster, all the previous downloaded images are gone. In this post, I explain why the default Docker network is a trap and how to set up a registry &amp; make sure that it actually works."/>
<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
  <link rel="stylesheet" type="text/css" media="screen" href="https://maelvls.dev/do-not-share-yet/css/normalize.css" />
  <link rel="stylesheet" type="text/css" media="screen" href="https://maelvls.dev/do-not-share-yet/css/main.css" />
  <link rel="stylesheet" type="text/css" media="screen" href="https://maelvls.dev/do-not-share-yet/css/all.css" />
<link rel="stylesheet" type="text/css" media="screen" href="https://maelvls.dev/do-not-share-yet/css/maelvls.css" /><title>Pull-through Docker registry on Kind clusters | maelvls dev blog</title></head>
<body>

<header>

  <div id="avatar">
    <a href="https://maelvls.dev/do-not-share-yet/">
      <img src="/img/mael.jpg" alt="maelvls dev blog">
    </a>
  </div>

  <div id="titletext"><h2 id="title"><a href="https://maelvls.dev/do-not-share-yet/">maelvls dev blog</a></h2></div>
  <div id="title-description"><p id="subtitle">Systems software engineer. I write mostly about Kubernetes and Go. <a href="/about/">About</a></p><div id=social>
    <nav>
      <ul><li><a href="https://github.com/maelvls"><i title="Github" class="icons fab fa-github"></i></a></li><li><a href="https://twitter.com/maelvls"><i title="Twitter" class="icons fab fa-twitter"></i></a></li><li><a href="https://dev.to/maelvls"><i title="Maël Valais&#39;s DEV Community Profile" class="icons fab fa-dev"></i></a></li></ul>
    </nav>
  </div>
  </div>
  <div id="mainmenu">
	
  </div>
</header>
<main><div class="post">
    <div class="author">
        
    </div>
    <div class="post-header">
        
        <div class="meta">
            <div class="date">
                <span class="day">03</span>
                <span class="rest">
                    
                    Jul2020
                    
                </span>
            </div>
        </div>
        
        <div class="matter">
            <h1 class="title">Pull-through Docker registry on Kind clusters</h1>
        </div>
        
        <span style="font-size: xx-small; text-align: right">
            cross-post <a href="https://dev.to/maelvls/pull-through-docker-registry-on-kind-clusters-cpo">
                <i title="Maël Valais's DEV Community Profile" class="icons fab fa-dev"></i>
            </a>
        </span>
        
    </div>
    <div class="markdown">
        <!--
Diagram on macOS + Docker: https://textik.com/#b185c1a72a6e782d
-->
<p><strong>TL;DR:</strong></p>
<ul>
<li>
<p>to create a local pull-through registry to speed up image pulling in a <a href="https://kind.sigs.k8s.io/">Kind</a> cluster, run:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">docker run -d --name proxy --restart<span class="o">=</span>always --net<span class="o">=</span>kind <span class="se">\
</span><span class="se"></span>  -e <span class="nv">REGISTRY_PROXY_REMOTEURL</span><span class="o">=</span>https://registry-1.docker.io registry:2
kind create cluster --config /dev/stdin <span class="s">&lt;&lt;EOF
</span><span class="s">kind: Cluster
</span><span class="s">apiVersion: kind.x-k8s.io/v1alpha4
</span><span class="s">containerdConfigPatches:
</span><span class="s">  - |-
</span><span class="s">    [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.mirrors.&#34;docker.io&#34;]
</span><span class="s">      endpoint = [&#34;http://proxy:5000&#34;]
</span><span class="s">EOF</span>
</code></pre></div></li>
<li>
<p><a href="https://docs.docker.com/registry/configuration/#proxy">you can&rsquo;t</a> use this pull-through proxy registry to push your own images (e.g. to <a href="https://github.com/tilt-dev/kind-local">speed up Tilt builds</a>), but you can create two registries (one for caching, the other for local images). See <a href="#docker-proxy-vs-local-registry">this section</a> for more context; the lines are:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">docker run -d --name proxy --restart<span class="o">=</span>always --net<span class="o">=</span>kind <span class="se">\
</span><span class="se"></span>  -e <span class="nv">REGISTRY_PROXY_REMOTEURL</span><span class="o">=</span>https://registry-1.docker.io registry:2
docker run -d --name registry --restart<span class="o">=</span>always --net<span class="o">=</span>kind <span class="se">\
</span><span class="se"></span>  -p 5000:5000 registry:2
kind create cluster --config /dev/stdin <span class="s">&lt;&lt;EOF
</span><span class="s">kind: Cluster
</span><span class="s">apiVersion: kind.x-k8s.io/v1alpha4
</span><span class="s">containerdConfigPatches:
</span><span class="s">  - |-
</span><span class="s">    [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.mirrors.&#34;docker.io&#34;]
</span><span class="s">      endpoint = [&#34;http://proxy:5000&#34;]
</span><span class="s">    [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.mirrors.&#34;localhost:5000&#34;]
</span><span class="s">      endpoint = [&#34;http://registry:5000&#34;]
</span><span class="s">EOF</span>
</code></pre></div></li>
<li>
<p>in case you often create &amp; delete Kind clusters, using a local registry that serves as a proxy avoids redundant downloads</p>
</li>
<li>
<p><code>KIND_EXPERIMENTAL_DOCKER_NETWORK</code> is useful but remember that the default network (<code>bridge</code>) doesn&rsquo;t have DNS resolution for container hostnames</p>
</li>
<li>
<p>the Docker default network (<code>bridge</code>) <a href="https://stackoverflow.com/questions/41400603/dockers-embedded-dns-on-the-default-bridged-network">has limitations</a> as <a href="https://docs.docker.com/network/bridge/#use-the-default-bridge-network">detailed by Docker</a>.</p>
</li>
<li>
<p>If you play with <a href="https://cluster-api.sigs.k8s.io/">ClusterAPI</a> with its <a href="https://github.com/kubernetes-sigs/cluster-api/tree/master/test/infrastructure/docker">Docker provider</a>, you might not be able to use a local registry due to the clusters being created on the default network, which means the &ldquo;proxy&rdquo; hostname won&rsquo;t be resolved (but we could work around that).</p>
</li>
</ul>
<hr>
<p><a href="https://kind.sigs.k8s.io/">Kind</a> is an awesome tool that allows you to spin up local Kubernetes clusters locally in seconds. It is perfect for Kubernetes developers or anyone who wants to play with controllers.</p>
<p>One thing I hate about Kind is that images are not cached between two Kind containers. Even worse: when deleting and re-creating a cluster, all the downloaded images disappear.</p>
<p>In this post, I detail my discoveries around local registries and why the default Docker network is a trap.</p>
<p><strong>Contents:</strong></p>
<ol>
<li><a href="#kind-has-no-image-caching-mechanism">Kind has no image caching mechanism</a></li>
<li><a href="#creating-a-caching-proxy-registry">Creating a caching proxy registry</a></li>
<li><a href="#creating-a-kind-cluster-that-knows-about-this-caching-proxy-registry">Creating a Kind cluster that knows about this caching proxy registry</a></li>
<li><a href="#check-that-the-caching-proxy-registry-works">Check that the caching proxy registry works</a></li>
<li><a href="#docker-proxy-vs-local-registry">Docker proxy vs. local registry</a></li>
<li><a href="#improving-the-clusterapi-docker-provider-to-use-a-given-network">Improving the ClusterAPI docker provider to use a given network</a></li>
</ol>
<hr>
<h2 id="kind-has-no-image-caching-mechanism">Kind has no image caching mechanism</h2>
<p>Whenever I re-create a Kind cluster and try to install ClusterAPI, all the (quite heavy) images have to be re-downloaded. Just take a look at all the images that get re-downloaded:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># That&#39;s the cluster created using &#39;kind create cluster&#39;</span>
% docker <span class="nb">exec</span> -it kind-control-plane crictl images
IMAGE                                                                      TAG      SIZE
quay.io/jetstack/cert-manager-cainjector                                   v0.11.0  11.1MB
quay.io/jetstack/cert-manager-controller                                   v0.11.0  14MB
quay.io/jetstack/cert-manager-webhook                                      v0.11.0  14.3MB
us.gcr.io/k8s-staging-capi-docker/capd-manager/capd-manager-amd64          dev      53.5MB
us.gcr.io/k8s-artifacts-prod/cluster-api/cluster-api-controller            v0.3.0   20.3MB
us.gcr.io/k8s-artifacts-prod/cluster-api/kubeadm-bootstrap-controller      v0.3.0   19.6MB
us.gcr.io/k8s-artifacts-prod/cluster-api/kubeadm-control-plane-controller  v0.3.0   21.1MB

<span class="c1"># I also use a ClusterAPI-created cluster (relying on CAPD):</span>
% docker <span class="nb">exec</span> -it capd-capd-control-plane-l4tx7 crictl images ls
docker.io/calico/cni                  v3.12.2             8b42391a46731       77.5MB
docker.io/calico/kube-controllers     v3.12.2             5ca01eb356b9a       23.1MB
docker.io/calico/node                 v3.12.2             4d501404ee9fa       89.7MB
docker.io/calico/pod2daemon-flexvol   v3.12.2             2abcc890ae54f       37.5MB
docker.io/metallb/controller          v0.9.3              4715cbeb69289       17.1MB
docker.io/metallb/speaker             v0.9.3              f241be9dae666       19.2MB
</code></pre></div><p>That&rsquo;s a total of 418 MB that get re-downloaded every time I restart both clusters!</p>
<p>Unfortunately, there is no way to re-use the image registry built into your default Docker engine (both on Linux and on macOS). One solution to this problem is to <a href="https://kind.sigs.k8s.io/docs/user/local-registry/">spin up an intermediary Docker registry</a> in a side container; as long as this container exists, all the images that have already been downloaded once can be served from cache.</p>
<h2 id="creating-a-caching-proxy-registry">Creating a caching proxy registry</h2>
<p>We want to create a registry with a simple Kind cluster; let&rsquo;s start with the registry:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">docker run -d --name proxy --restart<span class="o">=</span>always --net<span class="o">=</span>kind -e <span class="nv">REGISTRY_PROXY_REMOTEURL</span><span class="o">=</span>https://registry-1.docker.io registry:2
</code></pre></div><p>Details:</p>
<ul>
<li>
<p><code>--net kind</code> is required because Kind creates its containers in a separate network; it does that the because the &ldquo;bridge&rdquo; has <a href="https://docs.docker.com/network/bridge/#use-the-default-bridge-network">limitations</a> and <a href="https://docs.docker.com/config/containers/container-networking/#dns-services">doesn&rsquo;t allow you</a> to use container names as DNS names:</p>
<blockquote>
<p>By default, a container inherits the DNS settings of the host, as defined in the <code>/etc/resolv.conf</code> configuration file. Containers that use the default bridge network get a copy of this file, whereas containers that use a custom network use Docker’s embedded DNS server, which forwards external DNS lookups to the DNS servers configured on the host.</p>
</blockquote>
<p>which means that the container runtime (containerd) that runs our Kind cluster won&rsquo;t be able to resove the address <code>proxy:5000</code>.</p>
</li>
<li>
<p><code>REGISTRY_PROXY_REMOTEURL</code> is required due to the fact that by default, the registry won&rsquo;t forward requests. It simply tries to find the image in <code>/var/lib/registry/docker/registry/v2/repositories</code> and returns 404 if it doesn&rsquo;t find it.</p>
<blockquote>
<p>Using the <a href="https://docs.docker.com/registry/configuration/#proxy">pull-through</a> feature (I call it &ldquo;caching proxy&rdquo;), the registry will proxy all requests coming from all mirror prefixes and cache the blobs and manifests locally. To enable this feature, we set <code>REGISTRY_PROXY_REMOTEURL</code>.</p>
<p>Other interesting bit about <code>REGISTRY_PROXY_REMOTEURL</code>: this environement variable name is mapped from <a href="https://docs.docker.com/registry/configuration/#proxy">the registry YAML config API</a>. The variable</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nv">REGISTRY_PROXY_REMOTEURL</span><span class="o">=</span>https://registry-1.docker.io
</code></pre></div><p>is equivalent to the following YAML config:</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">proxy</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">remoteurl</span><span class="p">:</span><span class="w"> </span><span class="l">https://registry-1.docker.io</span><span class="w">
</span></code></pre></div></blockquote>
<p>⚠️ The registry can&rsquo;t be both in normal mode (&ldquo;local proxy&rdquo;) and in caching proxy mode at the same time, see <a href="#docker-proxy-vs-local-registry">below</a>.</p>
</li>
</ul>
<h2 id="creating-a-kind-cluster-that-knows-about-this-caching-proxy-registry">Creating a Kind cluster that knows about this caching proxy registry</h2>
<p>The second step is to create a Kind cluster and tell the container runtime to use a specific registry; here is the command to create it:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">kind create cluster --config /dev/stdin <span class="s">&lt;&lt;EOF
</span><span class="s">kind: Cluster
</span><span class="s">apiVersion: kind.x-k8s.io/v1alpha4
</span><span class="s">containerdConfigPatches:
</span><span class="s">  - |-
</span><span class="s">    [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.mirrors.&#34;docker.io&#34;]
</span><span class="s">      endpoint = [&#34;http://proxy:5000&#34;]
</span><span class="s">EOF</span>
</code></pre></div><p><strong>Note:</strong> <code>containerdConfigPatches</code> is a way to semantically patch <code>/etc/containerd/config.conf</code>. By default, this file looks like:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">% docker <span class="nb">exec</span> -it kind-control-plane cat /etc/containerd/config.toml
<span class="o">[</span>plugins<span class="o">]</span>
  <span class="o">[</span>plugins.<span class="s2">&#34;io.containerd.grpc.v1.cri&#34;</span><span class="o">]</span>
    <span class="o">[</span>plugins.<span class="s2">&#34;io.containerd.grpc.v1.cri&#34;</span>.registry<span class="o">]</span>
      <span class="o">[</span>plugins.<span class="s2">&#34;io.containerd.grpc.v1.cri&#34;</span>.registry.mirrors<span class="o">]</span>
        <span class="o">[</span>plugins.<span class="s2">&#34;io.containerd.grpc.v1.cri&#34;</span>.registry.mirrors.<span class="s2">&#34;docker.io&#34;</span><span class="o">]</span>
          <span class="nv">endpoint</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&#34;https://registry-1.docker.io&#34;</span><span class="o">]</span>
</code></pre></div><p><strong>Note 2:</strong> the mirror prefix (<code>docker.io</code>) can be omitted for images stored on Docker Hub. For other registries such as <code>gcr.io</code>, this mirror prefix has to be given. Here is a table with some examples of image names that are first prepended with &ldquo;docker.io&rdquo; if the mirror prefix is not present, and we get the final address by mapping these mirror prefixes with mirror entries:</p>
<table>
<thead>
<tr>
<th>image name</th>
<th>&ldquo;actual&rdquo; image name</th>
<th>registry address w.r.t. mirrors</th>
</tr>
</thead>
<tbody>
<tr>
<td>alpine</td>
<td>docker.io/alpine</td>
<td><a href="https://registry-1.docker.io/v2/library/alpine/manifests/latest">https://registry-1.docker.io/v2/library/alpine/manifests/latest</a></td>
</tr>
<tr>
<td>gcr.io/istio-release/pilot</td>
<td>gcr.io/istio-release/pilot</td>
<td><a href="https://gcr.io/v2/istio-release/pilot/manifests/1.9.1">https://gcr.io/v2/istio-release/pilot/manifests/1.9.1</a></td>
</tr>
<tr>
<td>foo.org/something/someimage</td>
<td>foo.org/something/someimage</td>
<td><a href="https://foo.org/v2/something/someimage/manifests/latest">https://foo.org/v2/something/someimage/manifests/latest</a></td>
</tr>
</tbody>
</table>
<h2 id="check-that-the-caching-proxy-registry-works">Check that the caching proxy registry works</h2>
<p>Let&rsquo;s see if the proxy registry works by running a pod:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">% kubectl run foo -it --rm --image<span class="o">=</span>nicolaka/netshoot
% docker <span class="nb">exec</span> -it proxy ls /var/lib/registry/docker/registry/v2/repositories
nicolaka
</code></pre></div><p>We can also see through the registry logs that everything is going well:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"># docker logs proxy | tail
time=&#34;2020-07-26T14:52:44.2624761Z&#34; level=info msg=&#34;Challenge established with upstream : {https registry-1.docker.io /v2/}&#34; go.version=go1.11.2 http.request.host=&#34;proxy:5000&#34; http.request.id=15e9ac86-7d79-4883-a8ce-861a7484887c http.request.method=HEAD http.request.remoteaddr=&#34;172.18.0.2:57588&#34; http.request.uri=&#34;/v2/nicolaka/netshoot/manifests/latest&#34; http.request.useragent=&#34;containerd/v1.4.0-beta.1-34-g49b0743c&#34; vars.name=&#34;nicolaka/netshoot&#34; vars.reference=latest
time=&#34;2020-07-26T14:52:45.4195817Z&#34; level=info msg=&#34;Adding new scheduler entry for nicolaka/netshoot@sha256:04786602e5a9463f40da65aea06fe5a825425c7df53b307daa21f828cfe40bf8 with ttl=167h59m59.9999793s&#34; go.version=go1.11.2 instance.id=ba959eb9-2fa3-47c0-beb7-91480c8a31ee service=registry version=v2.7.1
172.18.0.2 - - [26/Jul/2020:14:52:43 +0000] &#34;HEAD /v2/nicolaka/netshoot/manifests/latest HTTP/1.1&#34; 200 1999 &#34;&#34; &#34;containerd/v1.4.0-beta.1-34-g49b0743c&#34;
time=&#34;2020-07-26T14:52:45.4204299Z&#34; level=info msg=&#34;response completed&#34; go.version=go1.11.2 http.request.host=&#34;proxy:5000&#34; http.request.id=15e9ac86-7d79-4883-a8ce-861a7484887c http.request.method=HEAD http.request.remoteaddr=&#34;172.18.0.2:57588&#34; http.request.uri=&#34;/v2/nicolaka/netshoot/manifests/latest&#34; http.request.useragent=&#34;containerd/v1.4.0-beta.1-34-g49b0743c&#34; http.response.contenttype=&#34;application/vnd.docker.distribution.manifest.v2+json&#34; http.response.duration=1.6697112s http.response.status=200 http.response.written=1999
</code></pre></div><!--

## Why "proxy" wasn't resolved inside containers

```sh
% docker inspect proxy --format '{{range $net, $cfg := .NetworkSettings.Networks}}{{$net}} {{$cfg.IPAddress}}{{end}}'
bridge 172.17.0.2

% docker inspect kind-control-plane --format '{{range $net, $cfg := .NetworkSettings.Networks}}{{$net}} {{$cfg.IPAddress}}{{end}}'
kind 172.18.0.2

% docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
a6ceea984c68        bridge              bridge              local
6f6a9618d746        host                host                local
4927dc2eba9b        kind                bridge              local
```

Let's try to reproduce this issue. I first run a registry with the default
network, and I then try to connect to it from a second container using the
hostname `proxy`:

```sh
% docker run -d --rm --name proxy registry:2
% docker run -it --rm alpine nslookup proxy
Server:         127.0.0.11
Address:        127.0.0.11:53
Non-authoritative answer:
Name:   proxy
Address: 172.18.0.7

# Let's cleanup:
% docker kill proxy
```

Now, let's do the same but a custom network named "other" instead of the
default network:

```sh
% docker network create other
% docker run -d --rm --net=other --name proxy registry:2
% docker run -it --rm --net=other alpine nslookup proxy
Server:         127.0.0.11
Address:        127.0.0.11:53
Non-authoritative answer:
Name:   proxy
Address: 172.18.0.7

# Let's cleanup:
% docker kill proxy
```

I thought I could first start the container on the default network and then
move the containers to the "other" network (so that DNS with container
names works) but it does not seem to work either:

```sh
% docker run -d --rm --name proxy registry:2
% docker run -d --rm --name alpine alpine sleep 1d

% docker network create other
% docker network disconnect bridge proxy
% docker network disconnect bridge alpine
% docker network connect other proxy
% docker network connect other alpine

# Now, let's see if 'alpine' can resolve 'proxy':
% docker exec -it alpine nslookup proxy
```

I also tried to understand the difference between containers with the
default network and containers with the "other" network. As stated [in the
Docker documentation][dns-services], a container created on the default
network is setup slightly differently.

```sh
# 1️⃣ With default network:
% docker run -it --rm alpine cat /etc/resolv.conf
# This file is included on the metadata iso
nameserver 192.168.65.1

% docker run -it --rm alpine cat /etc/hosts
127.0.0.1       localhost
::1     localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
172.17.0.4      8f4a5e6bad39

# 2️⃣ With the 'other' network:
% docker run -it --rm --net=other alpine cat /etc/resolv.conf
nameserver 127.0.0.11
options ndots:0

% docker run -it --rm --net=other alpine cat /etc/hosts
127.0.0.1       localhost
::1     localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
172.19.0.4      fed220ca6bd0
```

So it definitely comes from `/etc/resolv.conf`! With the default network,
the `/etc/resolv.conf` that gets set up does not allow you to resolve
container names.

So in order to use container names as hostnames, I have to create your own
using `docker network create`.

Let's re-created my registry on the "kind" network and also re-create the
cluster without the `KIND_EXPERIMENTAL_DOCKER_NETWORK=bridge` option:

```sh
docker network create kind
docker run -d --name proxy --restart=always --net=kind registry:2
kind create cluster --config /dev/stdin <<EOF
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
containerdConfigPatches:
  - |-
    [plugins."io.containerd.grpc.v1.cri".registry.mirrors."proxy"]
      endpoint = ["http://proxy:5000"]
EOF
```

Both are now on the same subnet:

```sh
% docker inspect proxy --format '{{range $net, $cfg := .NetworkSettings.Networks}}{{$net}} {{$cfg.IPAddress}}{{end}}'
kind 172.18.0.2

% docker inspect kind-control-plane --format '{{range $net, $cfg := .NetworkSettings.Networks}}{{$net}} {{$cfg.IPAddress}}{{end}}'
kind 172.18.0.3
```

But creating a simple deployment doesn't seem to work! By looking at the
registry logs, we see no activity at all. Let's see what `containerd` is up
to:

```log
% docker exec -i kind-control-plane journalctl -u containerd | grep 'proxy:5000'
containerd[129]: Start cri plugin with config {Registry:{Mirrors:map[
  docker.io: {Endpoints:[https://registry-1.docker.io]}
  proxy:  {Endpoints:[http://proxy:5000]}
]}}
```

> ✅ I had to remove `-t` (tty) from the above command. That's because
> `journalctl` was using a pager because this terminal was TTY (which means
> it had /dev/stdin open? not sure). To disable the pager I removed `-t`.

I guess contained picks the first mirror (`docker.io`); so let's override
the `docker.io` key:

```sh
docker rm -f registry
docker run -d --name proxy --restart=always --net=kind registry:2
kind create cluster --config /dev/stdin <<EOF
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
containerdConfigPatches:
  - |-
    [plugins."io.containerd.grpc.v1.cri".registry.mirrors."docker.io"]
      endpoint = ["http://proxy:5000"]
EOF
```

And here is the actual configuration given to containerd:

```sh
% docker exec -it kind-control-plane cat /etc/containerd/config.toml
version = 2
[plugins]
  [plugins."io.containerd.grpc.v1.cri"]
    sandbox_image = "k8s.gcr.io/pause:3.2"
    [plugins."io.containerd.grpc.v1.cri".containerd]
      default_runtime_name = "runc"
      [plugins."io.containerd.grpc.v1.cri".containerd.runtimes]
        [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]
          runtime_type = "io.containerd.runc.v2"
        [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.test-handler]
          runtime_type = "io.containerd.runc.v2"
    [plugins."io.containerd.grpc.v1.cri".registry]
      [plugins."io.containerd.grpc.v1.cri".registry.mirrors]
        [plugins."io.containerd.grpc.v1.cri".registry.mirrors."docker.io"]
          endpoint = ["https://registry-1.docker.io"]
        [plugins."io.containerd.grpc.v1.cri".registry.mirrors."proxy"]
          endpoint = ["http://proxy:5000"]
```

-->
<h2 id="docker-proxy-vs-local-registry">Docker proxy vs. local registry</h2>
<p>A bit later, I discovered that <a href="https://docs.docker.com/registry/configuration/#proxy">you can&rsquo;t</a> push to a proxy registry. <a href="https://tilt.dev/">Tilt</a> is a tool I use to ease the process of developping in a containerized environment (and it works best with Kubernetes); it <a href="https://github.com/tilt-dev/kind-local">relies on a local registry</a> in order to cache build containers even when restarting the Kind cluster.</p>
<p>Either the registry is used as a &ldquo;local registry&rdquo; (where you can push images), or it is used as a pull-through proxy. So instead of configuring one single &ldquo;proxy&rdquo; registry, I configure two registries: one for local images, one for caching.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">docker run -d --name proxy --restart<span class="o">=</span>always --net<span class="o">=</span>kind -e <span class="nv">REGISTRY_PROXY_REMOTEURL</span><span class="o">=</span>https://registry-1.docker.io registry:2
docker run -d --name registry --restart<span class="o">=</span>always -p 5000:5000 --net<span class="o">=</span>kind registry:2
kind create cluster --config /dev/stdin <span class="s">&lt;&lt;EOF
</span><span class="s">kind: Cluster
</span><span class="s">apiVersion: kind.x-k8s.io/v1alpha4
</span><span class="s">containerdConfigPatches:
</span><span class="s">  - |-
</span><span class="s">    [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.mirrors.&#34;docker.io&#34;]
</span><span class="s">      endpoint = [&#34;http://proxy:5000&#34;]
</span><span class="s">    [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.mirrors.&#34;localhost:5000&#34;]
</span><span class="s">      endpoint = [&#34;http://registry:5000&#34;]
</span><span class="s">EOF</span>
</code></pre></div><p>Note that we do use a port-forwarding proxy (<code>-p 5000:5000</code>) so that we can push images &ldquo;from the host&rdquo;, e.g.:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">% docker tag alpine localhost:5000/alpine
% docker push localhost:5000/alpine
The push refers to repository <span class="o">[</span>localhost:5000/alpine<span class="o">]</span>
50644c29ef5a: Pushed
latest: digest: sha256:a15790640a6690aa1730c38cf0a440e2aa44aaca9b0e8931a9f2b0d7cc90fd65 size: <span class="m">528</span>

<span class="c1"># Let&#39;s see if this image is also available from the cluster:</span>
% docker <span class="nb">exec</span> -it kind-control-plane crictl pull localhost:5000/alpine
Image is up to date <span class="k">for</span> sha256:a24bb4013296f61e89ba57005a7b3e52274d8edd3ae2077d04395f806b63d83e
</code></pre></div><p>If you use Tilt, you might also want to tell Tilt that it can use the local registry. I find it a bit weird to have to set an annotation (hidden Tilt API?) but whatever. If you set this:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">kind get nodes <span class="p">|</span> xargs -L1 -I% kubectl annotate node % tilt.dev/registry<span class="o">=</span>localhost:5000 --overwrite
</code></pre></div><p>then Tilt will use <code>docker push localhost:5000/you-image</code> (from your host, not from the cluster container) in order to speed up things. Note that there is a proposal (<a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-cluster-lifecycle/generic/1755-communicating-a-local-registry">KEP 1755</a>) that aims at standardizing the discovery of local registries using a configmap. Tilt already supports it, so you may use it!</p>
<h2 id="improving-the-clusterapi-docker-provider-to-use-a-given-network">Improving the ClusterAPI docker provider to use a given network</h2>
<p>When I play with ClusterAPI, I usually use the CAPD provider (ClusterAPI Provider Docker). This provider <a href="https://github.com/kubernetes-sigs/cluster-api/blob/master/test/infrastructure/docker">is kept in-tree</a> inside the cluster-api projet.</p>
<p>I want to use the caching mechanism presented above. But to do that, I need to make sure the clusters created by CAPD are not created on the default network (<a href="https://sigs.k8s.io/cluster-api/test/infrastructure/docker/docker/kind_manager.go#L178">current implementation</a> creates CAPD clusters on the default &ldquo;bridge&rdquo; network).</p>
<p>I want to be able to customize the network on which the CAPD provider creates the container that make up the cluster. Imagine that we could pass the network name as part of a <a href="https://github.com/kubernetes-sigs/cluster-api/blob/6821939410c37743b45c36ec91d94c37dba1998e/test/e2e/data/infrastructure-docker/cluster-template.yaml#L26-L35">DockerMachineTemplate</a> (the content of the <code>spec</code> is defined in code <a href="https://github.com/kubernetes-sigs/cluster-api/blob/2ac3728d26593f7c54520999477aad45934e1c59/test/infrastructure/docker/api/v1alpha3/dockermachine_types.go#L30-L55">here</a>):</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">infrastructure.cluster.x-k8s.io/v1alpha3</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">DockerMachineTemplate</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">capd-control-plane</span><span class="w">
</span><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">extraMounts</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="nt">containerPath</span><span class="p">:</span><span class="w"> </span><span class="l">/var/run/docker.sock</span><span class="w">
</span><span class="w">          </span><span class="nt">hostPath</span><span class="p">:</span><span class="w"> </span><span class="l">/var/run/docker.sock</span><span class="w">
</span><span class="w">
</span><span class="w">      </span><span class="nt">network</span><span class="p">:</span><span class="w"> </span><span class="l">kind # 🔰 This field does not exist yet.</span><span class="w">
</span></code></pre></div><p><strong>Update 26 July 2020</strong>: added a section about local registry vs. caching proxy. Reworked the whole post (less noise, more useful information).</p>

    </div>
    <a href="https://github.com/maelvls/maelvls.github.io/edit/source/content/2020/docker-proxy-registry-kind/index.md">📝 Edit this page</a>
    <div class="tags">
        
        
        
        
        
        
        
        
        
        
        <div style="float: right;">
            <p>Tags:
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                <a href="/tags/dns/"> dns </a>
                
                
                
                
                
                <a href="/tags/docker/"> docker </a>
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                <a href="/tags/kind/"> kind </a>
                
                
                
                
                
                
                
                
                
                <a href="/tags/kubernetes/"> kubernetes </a>
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                <a href="/tags/networking/"> networking </a>
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
        </div>
        <div class="clearit"></div>
        
        
        
        
        
    </div>

<script
  src="https://utteranc.es/client.js"
  repo="maelvls/maelvls.github.io"
  issue-term="pathname"
  label="💬"
  theme="github-light"
  crossorigin="anonymous"
  async
></script>
</div>

</main><footer>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-88710120-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</footer>
</body>
</html>
