<!DOCTYPE html>
<html lang="en"><head>

  <meta name="generator" content="Hugo 0.64.0" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Maël Valais"><meta name="keywords" content="kubernetes,controllers"><meta name="description" content="Kubernetes&#39; extensibility is probably its biggest strength. Controllers and
CRDs are all over the place. But finding the right information to begin
writing a controller isn&#39;t easy due to the sheer amount of tribal knowledge
scattered everywhere. Here are some links to help you start.
"><meta property="og:title" content="Learning Kubernetes Controllers" />
<meta property="og:description" content="Kubernetes&#39; extensibility is probably its biggest strength. Controllers and
CRDs are all over the place. But finding the right information to begin
writing a controller isn&#39;t easy due to the sheer amount of tribal knowledge
scattered everywhere. Here are some links to help you start.
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://maelvls.dev/do-not-share-yet/learning-kubernetes-controllers/" />
<meta property="og:image" content="https://maelvls.dev/do-not-share-yet/learning-kubernetes-controllers/cover-learning-kubernetes-controllers.png" />
<meta property="article:published_time" content="2020-04-22T11:58:26+02:00" />
<meta property="article:modified_time" content="2020-04-22T11:58:26+02:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://maelvls.dev/do-not-share-yet/learning-kubernetes-controllers/cover-learning-kubernetes-controllers.png"/>

<meta name="twitter:title" content="Learning Kubernetes Controllers"/>
<meta name="twitter:description" content="Kubernetes&#39; extensibility is probably its biggest strength. Controllers and
CRDs are all over the place. But finding the right information to begin
writing a controller isn&#39;t easy due to the sheer amount of tribal knowledge
scattered everywhere. Here are some links to help you start.
"/>
<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
  <link rel="stylesheet" type="text/css" media="screen" href="https://maelvls.dev/do-not-share-yet/css/normalize.css" />
  <link rel="stylesheet" type="text/css" media="screen" href="https://maelvls.dev/do-not-share-yet/css/main.css" />
  <link rel="stylesheet" type="text/css" media="screen" href="https://maelvls.dev/do-not-share-yet/css/all.css" />
<link rel="stylesheet" type="text/css" media="screen" href="https://maelvls.dev/do-not-share-yet/css/maelvls.css" /><title>Learning Kubernetes Controllers | maelvls dev blog</title></head>
<body>

<header>

  <div id="avatar">
    <a href="https://maelvls.dev/do-not-share-yet/">
      <img src="/img/mael.jpg" alt="maelvls dev blog">
    </a>
  </div>

  <div id="titletext"><h2 id="title"><a href="https://maelvls.dev/do-not-share-yet/">maelvls dev blog</a></h2></div>
  <div id="title-description"><p id="subtitle">Systems software engineer. I write mostly about Kubernetes and Go. <a href="/about">About</a></p><div id=social>
    <nav>
      <ul><li><a href="https://github.com/maelvls"><i title="Github" class="icons fab fa-github"></i></a></li><li><a href="https://twitter.com/maelvls"><i title="Twitter" class="icons fab fa-twitter"></i></a></li></ul>
    </nav>
  </div>
  </div>
  <div id="mainmenu">
	
  </div>
</header>
<main><div class="post">
<div class="author">

</div>
<div class="post-header">

<div class="meta">
<div class="date">
<span class="day">22</span>
<span class="rest">Apr 2020</span>
</div>
</div>

<div class="matter">
<h1 class="title">Learning Kubernetes Controllers</h1>
</div>
</div>
<div class="markdown">
<p>Kubernetes&rsquo; extensibility is probably its biggest strength. Controllers and
CRDs are all over the place. But finding the right information to begin
writing a controller isn&rsquo;t easy due to the sheer amount of tribal knowledge
scattered everywhere. This post intends to help you start with controllers.</p>
<!--

> A "Kubernetes controller" is a binary that runs reconciliation loops. A
> reconciliation loop watches the objects stored in Kubernetes. When it
> notices a discrepency between what the object specifies (e.g. 4 replicas)
> and the observed reality (e.g., the reconcialiation loop asks kubelet,
> and it answers there are only 2 replicas), the reconcialiation loop will
> take actions in order to satisfy what is specified in the object. The
> "controller" binary is run as a simple Kubernetes Deployment. Sometimes,
> when the Kubernetes API is not enough, it may also come with some
> CustomResourceDefinitions YAML files.

I use interchangeably the term "sync loop" and "controller". The word
"controller" is quite overloaded: we use to qualify the binary that runs in
a pod and watches for objects ("Kubernetes controller"), but we also use it
to mean "one sync loop" that is running inside this binary.

Anyone writing Kubernetes controllers might want to take a look at the
following resources.
One controller

**[Kubernetes API conventions](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md)**

> When a new version of an object is POSTed or PUT, the "spec" is updated
> and available immediately. Over time the system will work to bring the
> "status" into line with the "spec". The system will drive toward the most
> recent "spec" regardless of previous versions of that stanza. In other
> words, if a value is changed from 2 to 5 in one PUT and then back down to
> 3 in another PUT the system is not required to 'touch base' at 5 before
> changing the "status" to 3. In other words, the system's behavior is
> level-based rather than edge-based. This enables robust behavior in the
> presence of missed intermediate state changes.

-->
<hr>
<p>Let us begin with some terminology:</p>
<ul>
<li>
<p><strong>controller</strong>: a single loop that watches some objects. We often refer
to this loop as &ldquo;controller loop&rdquo; or &ldquo;sync loop&rdquo; or &ldquo;reconcile loop&rdquo;.</p>
</li>
<li>
<p><strong>controller binary</strong> is a binary that runs one or multiple sync loops.
We often refer to it as &ldquo;controllers&rdquo;.</p>
</li>
<li>
<p><strong>CRD</strong> (Custom Resource Definition) is a simple YAML manifest that
describes a custom object, for example <a href="https://github.com/jetstack/cert-manager/blob/a04d2f0935/deploy/crds/crd-orders.yaml#L2">this
CRD</a>
defines the acme.cert-manager.io/v1alpha3 Order resource. After applying
this CRD to a Kubernetes cluster, you can apply manifests that have the
kind &ldquo;Order&rdquo;</p>
<blockquote>
<p>Note: CRDs and controllers are decoupled. You can apply a CRD manifest
without having any controller binary running. It works in both ways:
you can have a controller binary running that doesn&rsquo;t require any
custom objects. Traefik is a controller binary which relies on built-in
Service objects.</p>
</blockquote>
<blockquote>
<p>Note: the &ldquo;CRD&rdquo; manifest is just a schema. It doesn&rsquo;t carry any logic
(except for the basic validation the apiserver does). The actual logic
happens in the controller binary.</p>
</blockquote>
</li>
<li>
<p><strong>operator</strong>: the term &ldquo;operator&rdquo; is often used to mean a controller
binary with its CRDs, for example the <a href="https://github.com/elastic/cloud-on-k8s">elastic
operator</a>.</p>
</li>
</ul>
<hr>
<p>Here are the links that I would give to anyone interested in writing their
own controller:</p>
<ul>
<li>
<p><a href="https://github.com/kubernetes/community/blob/712590c108bd4533b80e8f2753cadaa617d9bdf2/contributors/devel/sig-api-machinery/controllers.md">sig-api-machinery/controllers.md</a>
gives a good intuition as to what a &ldquo;controller&rdquo; is:</p>
<blockquote>
<p>A Kubernetes controller is an active reconciliation process. That is,
it watches some object for the world&rsquo;s desired state, and it watches
the world&rsquo;s actual state, too. Then, it sends instructions to try and
make the world&rsquo;s current state be more like the desired state.</p>
</blockquote>
<p>Note: the client-go&rsquo;s informers and listers and workqueue are not
mandatory for writing a controller: you can just rely on client-go&rsquo;s
<code>Watch</code> primitive to reconcile state. The informers and workqueue add
important scalability and reliability features but these also come with
the cost of heavy abstractions. Use client-go&rsquo;s <code>Watch</code> first to have a
sense of what it can offer, and then try out informers and workqueue.</p>
</li>
<li>
<p><a href="https://book.kubebuilder.io/quick-start.html">Kubebuilder book</a> is a
nice starting point. Kubebuilder uses code generation a lot and that&rsquo;s
what most controllers use nowadays (Rancher uses a somehow forked version
of controller-runtime and controller-tools,
<a href="https://github.com/rancher/wrangler">Wrangler</a>, that also generates code
but with their own &ldquo;style&rdquo; – for example, simple flat interfaces instead
of <a href="https://github.com/kubernetes/client-go">client-go</a>&lsquo;s deeply nested
interfaces that don&rsquo;t feel like Go).</p>
</li>
<li>
<p>The <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md">Kubernetes API
conventions</a>
is an amazing document. It summarizes a lot of the &ldquo;tribal knowledge&rdquo;
around naming and how sync loops are conceived and what they mean by
&ldquo;level-based behaviour&rdquo;.</p>
</li>
<li>
<p>Github search &ldquo;<a href="https://github.com/search?q=language%3Ayaml+language%3Ago+kubernetes+controllers">language:yaml language:go kubernetes controllers</a>&quot;, tons of nice examples of controllers</p>
</li>
<li>
<p><a href="https://github.com/jetstack/cert-manager">cert-manager</a>&lsquo;s codebase is a nice controller to take a look at</p>
</li>
<li>
<p>ClusterAPI <a href="https://github.com/kubernetes-sigs/cluster-api/blob/master/docs/proposals/20190610-machine-states-preboot-bootstrapping.md">proposals</a> and codebase (<a href="https://github.com/kubernetes-sigs/cluster-api">capi</a>, <a href="https://github.com/kubernetes-sigs/cluster-api-provider-aws">capa</a>) and  (we took a lot of inspiration from what they do)</p>
</li>
<li>
<p>The ClusterAPI <a href="https://docs.google.com/document/d/1fQNlqsDkvEggWFi51GVxOglL2P1Bvo2JhZlMhm2d-Co/edit#">Meeting
notes</a> contains
a ton of useful information on Machine, MachinePool&hellip; (crazy how much I
learned from that).</p>
</li>
<li>
<p>The Kubernetes <code>status</code> field is tricky. You can take a look at
&ldquo;<a href="https://maelvls.dev/kubernetes-conditions/">conditions vs. phases vs.
reasons</a>&quot;.</p>
</li>
<li>
<p>The <a href="https://github.com/kubernetes/kubernetes">Kubernetes codebase</a>
itself is also a very nice read. It might feel overwhelming at first; I
invite you to take a look at a few of the following sync loops contained
in the <code>kube-controller-manager</code>, <code>kube-scheduler</code> and <code>kubelet</code>. Since
each sync loop reads or updates different objects, I also detail which
objects are updated or created by each sync loop:</p>
<table>
<thead>
<tr>
<th>binary</th>
<th>sync loop = component</th>
<th>reads</th>
<th>creates</th>
<th>updates</th>
</tr>
</thead>
<tbody>
<tr>
<td>kube-controller-manager</td>
<td><a href="https://github.com/kubernetes/kubernetes/blob/5bac42bf/pkg/controller/deployment/deployment_controller.go#L560-L649"><code>syncDeployment</code></a></td>
<td>Pod</td>
<td>ReplicaSet</td>
<td>Deployment</td>
</tr>
<tr>
<td>kube-controller-manager</td>
<td><a href="https://github.com/kubernetes/kubernetes/blob/5bac42bf/pkg/controller/replicaset/replica_set.go#L653-L721"><code>syncReplicaSet</code></a></td>
<td></td>
<td>Pod</td>
<td></td>
</tr>
<tr>
<td>kubelet</td>
<td><a href="https://github.com/kubernetes/kubernetes/blob/5bac42bf/pkg/kubelet/status/status_manager.go#L514-L567"><code>syncPod</code></a></td>
<td></td>
<td></td>
<td>Pod</td>
</tr>
<tr>
<td>kube-scheduler</td>
<td><a href="https://github.com/kubernetes/kubernetes/blob/5bac42bf/pkg/scheduler/scheduler.go#L589-L762"><code>scheduleOne</code></a></td>
<td></td>
<td></td>
<td>Pod</td>
</tr>
<tr>
<td>kubelet</td>
<td><a href="https://github.com/kubernetes/kubernetes/blob/5bac42bff9bfb9dfe0f2ea40f1c80cac47fc12b2/pkg/kubelet/kubelet_node_status.go#L374-L391"><code>syncNodeStatus</code></a></td>
<td></td>
<td></td>
<td>Node</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>The podcast episode &ldquo;<a href="https://changelog.com/gotime/105">Gotime #105 – Kubernetes and Cloud
Native</a>&rdquo; (Oct. 2019) with Joe Beda
(initiator of Kubernetes) and Kris Nova is very interesting and tells us
more about the genesis of the project, which things like why is
Kubernetes written in Go and why client-go feels like Java. For example:</p>
<blockquote>
<p><strong>Kris Nova:</strong> I think there’s a fourth role. I think there’s what we
called in the book an infrastructure engineer. These are effectively
the folks like Joe and myself. These are the folks who are writing
software to manage and mutate infrastructure behind the scenes. Folks
who are contributing to Kubernetes, folks who are writing the software
for the operators, folks who are writing admission controller
implementations and so forth… I think it’s this very new engineer role,
that we haven’t seen until we’ve started having – effectively, as Joe
likes to put it, a platform-platform.</p>
</blockquote>
</li>
<li>
<p>The <a href="https://github.com/operator-framework/operator-sdk">operator-sdk</a>
(RedHat) is a package that aims at helping dealing with the whole
scafollding when writing a sync loop. It relies on
<a href="https://github.com/kubernetes-sigs/controller-runtime">controller-runtime</a>.
I don&rsquo;t use either of them but taking a look at these projects helps
getting more understanding about the challenges (read: boilerplate) that
comes when writing controllers. I personally write all the
controller-related boilerplate myself (creating the queue, setting event
handlers, running the loop itself&hellip;).</p>
</li>
</ul>
<p>And a final note: CRDs are not necessary for writing a controller! You can
write a tiny controller that watches the &ldquo;standard&rdquo; Kubernetes objects.
That&rsquo;s exactly what ingress controllers do: they watch for Service objects.</p>
<ul>
<li><strong>Update 23 April 2020</strong>: I added a quote from Kris Nova! 😁</li>
<li><strong>Update 2 May 2020</strong>: Rephrased the &ldquo;terminology&rdquo; bullet points to make
them clearer and added a note on CRD vs. controller binary.</li>
</ul>

</div>
<a href="https://github.com/maelvls/maelvls.github.io/edit/source/content/2020/learning-kubernetes-controllers/index.md">📝 Edit this page and propose a change!</a>
<div class="tags">










<div style="float: right;">
<p>Tags:























<a href="/tags/controllers/"> controllers </a>













































<a href="/tags/kubernetes/"> kubernetes </a>

























































</div>
<div class="clearit"></div>





</div>

<script
  src="https://utteranc.es/client.js"
  repo="maelvls/maelvls.github.io"
  issue-term="pathname"
  label="💬"
  theme="github-light"
  crossorigin="anonymous"
  async
></script>
</div>

</main><footer>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-88710120-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</footer>
</body>
</html>
