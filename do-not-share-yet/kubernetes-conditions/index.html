<!DOCTYPE html>
<html lang="en"><head>

  <meta name="generator" content="Hugo 0.64.0" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="keywords" content="kubernetes,go,controller"><meta name="description" content="Although progress is being made, Kubernetes controllers and operators
still require prior knowledge about Kubernetes internals. Information on
how to set the status is scattered across comments, issues, PRs and the
Kubernetes code itself. Conditions may be a good solution for your
controller, but for what?
"><meta property="og:title" content="Use of conditions in Kubernetes controllers" />
<meta property="og:description" content="Although progress is being made, Kubernetes controllers and operators
still require prior knowledge about Kubernetes internals. Information on
how to set the status is scattered across comments, issues, PRs and the
Kubernetes code itself. Conditions may be a good solution for your
controller, but for what?
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://maelvls.dev/do-not-share-yet/kubernetes-conditions/" />
<meta property="og:image" content="https://maelvls.dev/do-not-share-yet/kubernetes-conditions/cover-kubernetes-conditions.png" />
<meta property="article:published_time" content="2019-11-12T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-11-12T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://maelvls.dev/do-not-share-yet/kubernetes-conditions/cover-kubernetes-conditions.png"/>

<meta name="twitter:title" content="Use of conditions in Kubernetes controllers"/>
<meta name="twitter:description" content="Although progress is being made, Kubernetes controllers and operators
still require prior knowledge about Kubernetes internals. Information on
how to set the status is scattered across comments, issues, PRs and the
Kubernetes code itself. Conditions may be a good solution for your
controller, but for what?
"/>

  <link rel="stylesheet" type="text/css" media="screen" href="https://maelvls.dev/do-not-share-yet/css/normalize.css" />
  <link rel="stylesheet" type="text/css" media="screen" href="https://maelvls.dev/do-not-share-yet/css/main.css" />
  <link rel="stylesheet" type="text/css" media="screen" href="https://maelvls.dev/do-not-share-yet/css/all.css" />
<link rel="stylesheet" type="text/css" media="screen" href="https://maelvls.dev/do-not-share-yet/css/maelvls.css" /><title>Use of conditions in Kubernetes controllers | maelvls dev blog</title></head>
<body>

<header>

  <div id="avatar">
    <a href="https://maelvls.dev/do-not-share-yet/">
      <img src="/img/mael.jpg" alt="maelvls dev blog">
    </a>
  </div>

  <div id="titletext"><h2 id="title"><a href="https://maelvls.dev/do-not-share-yet/">maelvls dev blog</a></h2></div>
  <div id="title-description"><p id="subtitle">Systems software engineer. I write mostly about Kubernetes and Go. <a href="/about">About</a></p><div id=social>
    <nav>
      <ul><li><a href="https://github.com/maelvls"><i title="Github" class="icons fab fa-github"></i></a></li><li><a href="https://twitter.com/maelvls"><i title="Twitter" class="icons fab fa-twitter"></i></a></li></ul>
    </nav>
  </div>
  </div>
  <div id="mainmenu">
	
  </div>
</header>
<main><div class="post">
<div class="author">

</div>
<div class="post-header">

<div class="meta">
<div class="date">
<span class="day">12</span>
<span class="rest">Nov 2019</span>
</div>
</div>

<div class="matter">
<h1 class="title">Use of conditions in Kubernetes controllers</h1>
</div>
</div>
<div class="markdown">
<p>While building a Kubernetes controller using CRDs, I stumbled across
&lsquo;conditions&rsquo; in the status field. What are conditions and how should I
implement them in my controller?</p>
<p>In this post, I will explain what &lsquo;status conditions&rsquo; are in Kubernetes and
show how they can be used in your own controllers.</p>
<hr>
<p>Table of contents:</p>
<ol>
<li><a href="#pod-example">Pod example</a></li>
<li><a href="#what-other-projects-do">What other projects do</a></li>
<li><a href="#conditions-vs-state-machine">Conditions vs. State machine</a></li>
<li><a href="#conditions-vs-events">Conditions vs. Events</a></li>
<li><a href="#orthogonality-vs-extensibility">Orthogonality vs. Extensibility</a></li>
<li><a href="#are-conditions-still-used">Are Conditions still used?</a></li>
<li><a href="#conditions-vs-reasons">Conditions vs. Reasons</a></li>
<li><a href="#how-many-conditions">How many conditions?</a></li>
</ol>
<hr>
<p>In the following, a &lsquo;component&rsquo; is considered to be one sync loop. A sync
loop (also called reconciliation loop) is what must be done in order to
synchronize the &lsquo;desired state&rsquo; with the &lsquo;observed state&rsquo;.</p>
<p>Kubernetes itself is made of multiple binaries (kubelet on each node, one
apiserver, one kube-controller-manager and one kube-scheduler). And each of
these binaries have multiple components (i.e., sync loops):</p>
<table>
<thead>
<tr>
<th>binary</th>
<th>sync loop = component</th>
<th>reads</th>
<th>creates</th>
<th>updates</th>
</tr>
</thead>
<tbody>
<tr>
<td>kube-controller-manager</td>
<td><a href="https://github.com/kubernetes/kubernetes/blob/5bac42bf/pkg/controller/deployment/deployment_controller.go#L560-L649"><code>syncDeployment</code></a></td>
<td>Pod</td>
<td>ReplicaSet</td>
<td>Deployment</td>
</tr>
<tr>
<td>kube-controller-manager</td>
<td><a href="https://github.com/kubernetes/kubernetes/blob/5bac42bf/pkg/controller/replicaset/replica_set.go#L653-L721"><code>syncReplicaSet</code></a></td>
<td></td>
<td>Pod</td>
<td></td>
</tr>
<tr>
<td>kubelet</td>
<td><a href="https://github.com/kubernetes/kubernetes/blob/5bac42bf/pkg/kubelet/status/status_manager.go#L514-L567"><code>syncPod</code></a></td>
<td></td>
<td></td>
<td>Pod</td>
</tr>
<tr>
<td>kube-scheduler</td>
<td><a href="https://github.com/kubernetes/kubernetes/blob/5bac42bf/pkg/scheduler/scheduler.go#L589-L762"><code>scheduleOne</code></a></td>
<td></td>
<td></td>
<td>Pod</td>
</tr>
<tr>
<td>kubelet</td>
<td><a href="https://github.com/kubernetes/kubernetes/blob/5bac42bff9bfb9dfe0f2ea40f1c80cac47fc12b2/pkg/kubelet/kubelet_node_status.go#L374-L391"><code>syncNodeStatus</code></a></td>
<td></td>
<td></td>
<td>Node</td>
</tr>
</tbody>
</table>
<p>We can see that one single object (Pod) can be read, edited and updated by
different components. When I say &lsquo;edited&rsquo;, I mean the sync loop edits the
status (which contains the conditions), not the rest. The status is a way
of communicating between components/sync loops.</p>
<p>As Brian Grant put it,</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Rather than rigid fine-grained state enumerations that couldn&#39;t be evolved, we initially adopted simple basic states that could report open-ended reasons for being in each state (<a href="https://t.co/l5WXSjbg3K">https://t.co/l5WXSjbg3K</a>), and later non-orthogonal, extensible conditions (<a href="https://t.co/XiwOcgcSGY">https://t.co/XiwOcgcSGY</a>).</p>&mdash; Brian Grant (@bgrant0607) <a href="https://twitter.com/bgrant0607/status/1111473660479430656?ref_src=twsrc%5Etfw">March 29, 2019</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2 id="pod-example">Pod example</h2>
<p>Let&rsquo;s read a Pod manifest:</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="c"># kubectl -n cert-manager get pods -oyaml</span><span class="w">
</span><span class="w"></span><span class="k">kind</span><span class="p">:</span><span class="w"> </span>Pod<span class="w">
</span><span class="w"></span><span class="k">status</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="k">conditions</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">    </span>- <span class="k">lastTransitionTime</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;2019-10-22T16:29:24Z&#34;</span><span class="w">
</span><span class="w">      </span><span class="k">status</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;True&#34;</span><span class="w">
</span><span class="w">      </span><span class="k">type</span><span class="p">:</span><span class="w"> </span>PodScheduled<span class="w">
</span><span class="w">    </span>- <span class="k">lastTransitionTime</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;2019-10-22T16:29:24Z&#34;</span><span class="w">
</span><span class="w">      </span><span class="k">status</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;True&#34;</span><span class="w">
</span><span class="w">      </span><span class="k">type</span><span class="p">:</span><span class="w"> </span>Initialized<span class="w">
</span><span class="w">    </span>- <span class="k">lastTransitionTime</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;2019-10-22T16:29:31Z&#34;</span><span class="w">
</span><span class="w">      </span><span class="k">status</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;True&#34;</span><span class="w">
</span><span class="w">      </span><span class="k">type</span><span class="p">:</span><span class="w"> </span>ContainersReady<span class="w">
</span><span class="w">    </span>- <span class="k">lastTransitionTime</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;2019-10-22T16:29:31Z&#34;</span><span class="w">
</span><span class="w">      </span><span class="k">status</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;True&#34;</span><span class="w">
</span><span class="w">      </span><span class="k">type</span><span class="p">:</span><span class="w"> </span>Ready<span class="w">
</span><span class="w">  </span><span class="k">containerStatuses</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">    </span>- <span class="k">image</span><span class="p">:</span><span class="w"> </span>quay.io/jetstack/cert-manager-controller<span class="p">:</span>v0<span class="m">.6</span><span class="m">.1</span><span class="w">
</span><span class="w">      </span><span class="k">ready</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="w">      </span><span class="k">state</span><span class="p">:</span><span class="w"> </span>{<span class="w"> </span><span class="k">running</span><span class="p">:</span><span class="w"> </span>{<span class="w"> </span><span class="k">startedAt</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;2019-10-22T16:29:31Z&#34;</span><span class="w"> </span>}<span class="w"> </span>}<span class="w">
</span><span class="w">  </span><span class="k">phase</span><span class="p">:</span><span class="w"> </span>Running<span class="w">
</span></code></pre></div><p>A condition contains a Status and a Type. It may also contain a Reason and
a Message. For example:</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml">- <span class="k">lastTransitionTime</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;2019-10-22T16:29:31Z&#34;</span><span class="w">
</span><span class="w">  </span><span class="k">status</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;True&#34;</span><span class="w">
</span><span class="w">  </span><span class="k">type</span><span class="p">:</span><span class="w"> </span>ContainersReady<span class="w">
</span></code></pre></div><p>The <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions">pod-lifecycle</a> documentation explains the difference between the
&lsquo;phase&rsquo; and &lsquo;conditions:</p>
<ol>
<li>The top-level <code>phase</code> is an aggregated state that answers some
user-facing questions such as <em>is my pod in a terminal state?</em> but has
gaps since the actual state is contained in the conditions.</li>
<li>The <code>conditions</code> array is a set of types (Ready, PodScheduled&hellip;) with a
status (True, False or Unknown) that make up the &lsquo;computed state&rsquo; of a
Pod at any time. As we will see later, the state is almost always
&lsquo;partial&rsquo; (<em>open-ended conditions</em>).</li>
</ol>
<p>Now, let&rsquo;s see what I mean by &lsquo;components&rsquo;. The status of a Pod is not
updated by a single Sync loop: it is updated by multiple components: the
kubelet, and the kube-scheduler. Here is a list of the condition types per
component:</p>
<table>
<thead>
<tr>
<th>Possible condition types for a Pod</th>
<th>Component that updates this condition type</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/kubernetes/kubernetes/blob/beaf3a2f0/pkg/scheduler/scheduler.go#L435">PodScheduled</a></td>
<td><a href="https://github.com/kubernetes/kubernetes/blob/5bac42bf/pkg/scheduler/scheduler.go#L589-L762"><code>scheduleOne</code></a> (kube-scheduler)</td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/kubernetes/blob/beaf3a2f0/pkg/scheduler/scheduler.go#L615">Unschedulable</a></td>
<td><a href="https://github.com/kubernetes/kubernetes/blob/5bac42bf/pkg/scheduler/scheduler.go#L589-L762"><code>scheduleOne</code></a> (kube-scheduler)</td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/kubernetes/blob/beaf3a2f0/pkg/kubelet/kubelet_pods.go#L1368">Initialized</a></td>
<td><a href="https://github.com/kubernetes/kubernetes/blob/5bac42bf/pkg/kubelet/status/status_manager.go#L514-L567"><code>syncPod</code></a> (kubelet)</td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/kubernetes/blob/beaf3a2f0/pkg/kubelet/kubelet_pods.go#L1370">ContainersReady</a></td>
<td><a href="https://github.com/kubernetes/kubernetes/blob/5bac42bf/pkg/kubelet/status/status_manager.go#L514-L567"><code>syncPod</code></a> (kubelet)</td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/kubernetes/blob/beaf3a2f0/pkg/kubelet/kubelet_pods.go#L1369">Ready</a></td>
<td><a href="https://github.com/kubernetes/kubernetes/blob/5bac42bf/pkg/kubelet/status/status_manager.go#L514-L567"><code>syncPod</code></a> (kubelet)</td>
</tr>
</tbody>
</table>
<p>Although conditions are a good way to convey information to the user, they
also serve as a way of communicating between components (e.g., between
kube-scheduler and apiserver) but also to external components (e.g. a
custom controller that wants to trigger something as soon as a pod becomes
&lsquo;Unschedulable&rsquo;, and maybe order more VMs to the cloud provider and add it
as a node.</p>
<p>As you will see below, the &lsquo;conditions&rsquo; array is considered to be
containing all the &lsquo;ground truth&rsquo;. The &lsquo;phase&rsquo; just an abstraction of these
conditions.</p>
<h2 id="what-other-projects-do">What other projects do</h2>
<ul>
<li>
<p><a href="https://github.com/kubernetes-sigs/cluster-api">cluster-api</a> and its
providers (e.g., cluster-api-gcp-provider) do not use Conditions at all:</p>
<blockquote>
<p>(<a href="https://github.com/kubernetes-sigs/cluster-api/blob/112951ee/docs/proposals/20181121-machine-api.md">Feng Min, Nov
2018</a>)
Brian Grant (@bgrant0607) and Eric Tune (@erictune) have indicated that
the API pattern of having &ldquo;Conditions&rdquo; lists in object statuses is soon
to be deprecated. These have generally been used as a timeline of state
transitions for the object&rsquo;s reconciliation, and difficult to consume
for clients that just want a meaningful representation of the object&rsquo;s
current state. There are no existing examples of the new pattern to
follow instead, just the guidance that we should use top-level fields
in the status to represent meaningful information. We can revisit the
specifics when new patterns start to emerge in core.</p>
</blockquote>
<p>Instead of using a list of conditions, cluster-api projects go like that:</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">status</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="k">ready</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span><span class="w">  </span><span class="k">phase</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;Failed&#34;</span><span class="w">
</span><span class="w">  </span><span class="k">failureReason</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;GcpMachineCrashed&#34;</span><span class="w">
</span><span class="w">  </span><span class="k">failureMessage</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;VM crashed: ...&#34;</span><span class="w">
</span></code></pre></div></li>
<li>
<p><a href="https://github.com/jetstack/cert-manager">cert-manager</a> uses Conditions,
but the only type is &lsquo;Ready&rsquo;. The rest of the information is given in
Ready&rsquo;s Reason field. That might be unfortunate for users or other
components that are willing to use cert-manager&rsquo;s API, similarly to what
happens with the PodSchedulable condition and its reason,
PodReasonUnschedulable. For example, the <a href="https://github.com/jetstack/cert-manager/blob/b91b7d8d3/pkg/controller/issuers/sync.go#L61-L69">Issuer&rsquo;s
Sync</a>:</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">kind</span><span class="p">:</span><span class="w"> </span>Issuer<span class="w">
</span><span class="w"></span><span class="k">status</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="k">conditions</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">    </span>- <span class="k">type</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;Ready&#34;</span><span class="w">
</span><span class="w">      </span><span class="k">status</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;False&#34;</span><span class="w">
</span><span class="w">      </span><span class="k">reason</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;ErrorConfig&#34;</span><span class="w">
</span><span class="w">      </span><span class="k">message</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;Resource validation failed: ...&#34;</span><span class="w">
</span></code></pre></div></li>
<li>
<p>Openshift uses conditions a lot but does not use the standard &lsquo;Ready&rsquo;
type. For example, cluster-version-operators (CVO) has a <a href="https://github.com/openshift/api/blob/b1bcdbc3/config/v1/types_cluster_operator.go#L123-L134"><code>kind: ClusterOperator</code></a>
with condition types &lsquo;Available&rsquo;, &lsquo;Progressing&rsquo;, &lsquo;Degraded&rsquo; and
&lsquo;Upgradeable&rsquo;.</p>
</li>
<li>
<p>Hyperconverged Cluster Operator (HCO) uses conditions but in a slightly
different way that cert-manager or openshift does. Each condition is set
by a different component</p>
<blockquote>
<p>It&rsquo;s important to point out that the Condition types on the HCO don&rsquo;t
represent the condition the HCO is in, rather the condition of the
component CRs.</p>
</blockquote>
</li>
<li>
<p>Gardener also uses conditions, and like Openshift, it doesn&rsquo;t rely on the
standard &lsquo;Ready&rsquo; type. For example, the <a href="https://github.com/gardener/gardener/blob/161695ada/pkg/apis/core/v1alpha1/types_controllerinstallation.go"><code>kind: ControllerInstallation</code></a>
has conditions types &lsquo;Valid&rsquo; and &lsquo;Installed&rsquo;.</p>
</li>
</ul>
<p>We see a lot of variance across projects. In late 2017, we saw some
uncertainty about Conditions disappearing. In the remaining of this post, I
will try to give answers as to why you should use conditions and how to do
so.</p>
<h2 id="conditions-vs-state-machine">Conditions vs. State machine</h2>
<blockquote>
<p>(<a href="https://github.com/kubernetes/community/blob/a2cdce5/contributors/devel/sig-architecture/api-conventions.md">api-conventions</a>, July 2017) Conditions are observations and not, themselves, state machines.</p>
</blockquote>
<p>So, what is the difference between a state in a state machine and an
observation? A state machine has a known a fixed state. In comparison,
conditions offers an &lsquo;open-world&rsquo; perspective with the Unknown value. For
example, the status of a Pod is partly constructed by the kube-scheduler,
partly by the kubelet.</p>
<p>But when an object gets created, no conditions are present. What does that
mean?</p>
<blockquote>
<p>(<a href="https://issues.k8s.io/7856#issuecomment-99657942">Tim Hockin, May
2015</a>) The absence of a
condition should be interpreted the same as Unknown.</p>
</blockquote>
<p>In the end, this set of conditions are just a way of communicating changes
of state between components, and this state can always be reconstructed by
observing the system:</p>
<blockquote>
<p>(<a href="https://github.com/kubernetes/community/blob/06207d2/contributors/design-proposals/architecture/principles">principles</a>, 2015) Object status must be 100% reconstructable by
observation. Any history kept (E.g., through conditions or other fields in
&lsquo;status&rsquo;) must be just an optimization and not required for correct
operation.</p>
<p>Do not define comprehensive state machines for objects with behaviors
associated with state transitions and/or &ldquo;assumed&rdquo; states that cannot be
ascertained by observation.</p>
</blockquote>
<p>One last comment that explains why the Kubernetes docs don&rsquo;t have any
state-machine diagram:</p>
<blockquote>
<p>(<a href="https://issues.k8s.io/24130">Tim Hockin, Apr 2016</a>) This
[state-machine-alike diagram representing the Pod states] is not strictly
correct though, because a pod can cease to be &ldquo;ready&rdquo; but not die. We&rsquo;ve
intentionally NOT drawn this as a state-machine because conditions are
really orthogonal concepts. We report a singular status as part of
kubectl, so maybe we should document THAT, but it&rsquo;s more complicated than
this diagram captures.</p>
</blockquote>
<h2 id="conditions-vs-events">Conditions vs. Events</h2>
<p>Events are meant to save history (for non-machine consumption, i.e., for humans). The set of conditions describes the &lsquo;current&rsquo; state:</p>
<blockquote>
<p>(<a href="https://issues.k8s.io/7856#issuecomment-323196033">Brian Grant, Aug
2017</a> Status,
represented as conditions or otherwise, should be complementary to events
pertaining to the resource. Events provide additional information for
debugging and tracing, akin to log messages, but aren&rsquo;t intended to be
used for event-driven automation.</p>
</blockquote>
<p>It was reminded in 2019:</p>
<blockquote>
<p>(<a href="https://issues.k8s.io/51594#issuecomment-334646068">Kenneth Owens, Oct
2019</a>) Events are
used to express point in time occurrences, and Conditions are used to
express the current state of an ongoing process. For instance, Pod
creation is an event, Deployment progressing is a condition.</p>
</blockquote>
<h2 id="orthogonality-vs-extensibility">Orthogonality vs. Extensibility</h2>
<p>In 2015, the Kubernetes team seemed to be attached to the idea of
&lsquo;orthogonality&rsquo; between conditions.</p>
<blockquote>
<p>(<a href="https://issues.k8s.io/6951#issuecomment-94203495">David Oppenheimer, Apr
2015</a>) To avoid
confusion, Conditions should be orthogonal. The ones you suggested &ndash;
Instantiated, Initialized, and Terminated &ndash; don&rsquo;t seem to be orthogonal
(in fact I would expect a pod to transition from FFF to TFF to TTF to
TTT). What you&rsquo;ve described sounds more like a state machine than a set
of orthogonal conditions, and I think Conditions should only be used for
the latter.</p>
</blockquote>
<p>In 2017, things start to get confusing: <em>each condition represents one
non-orthogonal &ldquo;state&rdquo; of a resource</em>?! Conditions are orthogonal to each
other, but the states that they represent may be non-orthogonal&hellip;</p>
<blockquote>
<p>(<a href="https://issues.k8s.io/7856#issuecomment-323196033">Brian Grant, Aug
2017</a>) Conditions were
created as a way to wean contributors off of the idea of state machines
with mutually exclusive states (called &ldquo;phase&rdquo;).</p>
<p>Each condition should represent a non-orthogonal &ldquo;state&rdquo; of a resource &ndash;
is the resource in that state or not (or unknown).</p>
<p>Arbitrarily typed/structured status properties specific to a particular
resource should just be status fields.</p>
</blockquote>
<p>I did not find anywhere a definition of &lsquo;orthogonal condition&rsquo;; my guess is
that two conditions are orthogonal when they explain two uncorrelated parts
of the system.</p>
<p>But in 2019, the narrative seems to have changed: Brian Grant talks about
&lsquo;non-orthogonal &amp; extensible conditions&rsquo;.</p>
<blockquote>
<p>(<a href="https://twitter.com/bgrant0607/status/1111473660479430656">Brian Grant, Mar
2019</a>) Rather
than rigid fine-grained state enumerations that couldn&rsquo;t be evolved, we
initially adopted simple basic states that could report open-ended
reasons for being in each state (<a href="http://issues.k8s.io/1146">http://issues.k8s.io/1146</a>), and later
non-orthogonal, extensible conditions (<a href="http://issues.k8s.io/7856">http://issues.k8s.io/7856</a>).</p>
</blockquote>
<p>Orthogonality was hard to implement anyway:</p>
<blockquote>
<p>(<a href="https://issues.k8s.io/7856#issuecomment-325978016">Steven E. Harris, Aug
2019</a>) The burden is
on the status type author to come up with dimensions that are orthogonal;
that required careful thought when writing my own condition types.</p>
</blockquote>
<p>Here is what I think: you should definitely use conditions, but don&rsquo;t
bother with orthogonality. Just use conditions that represent important
changes for the object, beginning with the &lsquo;Ready&rsquo; condition type. &lsquo;Ready&rsquo;
is the strongest condition of all and indicates something 100% operational.</p>
<h2 id="are-conditions-still-used">Are Conditions still used?</h2>
<p>There was an extensive dicussion about removing or keeping these
conditions. They were described by <a href="https://issues.k8s.io/7856#issuecomment-323196033">Brian Grant in Aug
2017</a> as cumbersome (an
array is harder to deal with than top-level fields) and confusing because
of the open-ended statuses (True, False, Unknown). In 2019, the Kubernetes
stated that conditions are still what controller authors should use:</p>
<blockquote>
<p>(<a href="https://issues.k8s.io/7856#issuecomment-492812566">Daniel Smith, May 2019</a>)
Conditions are not going to be removed.</p>
<p>The ground truth is set as conditions by the components that are nearby,
e.g. kubelet sets &ldquo;DiskPressure = True&rdquo;.</p>
<p>The set of conditions is summarized into phases (or secondary conditions)
for consumption by general controllers. E.g., if there is disk pressure,
that can be aggregated into <code>conditionSummary.schedulable: false</code>. The
process doing this needs to know all possible gound truth statements; the
process of summarizing them isolates the rest of the cluster from needing
to know this.</p>
</blockquote>
<h2 id="conditions-vs-reasons">Conditions vs. Reasons</h2>
<p>Do I really need to bother with this <code>.status.conditions</code> array, can I just
use <code>.status.phase</code> with a simple enum? Or just a <code>reason</code> as part of an
existing &lsquo;Ready&rsquo; condition?</p>
<p>At first, Kubernetes would rely on many Reasons:</p>
<blockquote>
<p>(<a href="https://github.com/kubernetes/community/blob/a2cdce5/contributors/devel/sig-architecture/api-conventions.md">api-conventions</a>, July 2017) In condition types, and everywhere else
they appear in the API, <code>Reason</code> is intended to be a one-word, CamelCase
representation of the category of cause of the current status, and
<code>Message</code> is intended to be a human-readable phrase or sentence, which
may contain specific details of the individual occurrence.</p>
<p><code>Reason</code> is intended to be used in concise output, such as one-line
kubectl get output, and in summarizing occurrences of causes, whereas
<code>Message</code> is intended to be presented to users in detailed status
explanations, such as kubectl describe output.</p>
</blockquote>
<p>Later, they mode to non-orthogonal (read: may-be-corrolated conditions):</p>
<blockquote>
<p>(<a href="https://twitter.com/bgrant0607/status/1111473660479430656">Brian Grant, Mar 2019</a>) Rather than rigid fine-grained state enumerations that couldn&rsquo;t be evolved, we initially adopted simple basic states that could report <a href="http://issues.k8s.io/1146">open-ended reasons for being in each state</a> (2014), and later <a href="http://issues.k8s.io/7856">non-orthogonal, extensible conditions</a> (2017).</p>
</blockquote>
<p>Since the Pod conditions do not have a &lsquo;Reason&rsquo; field (in the previous Pod example), let&rsquo;s take a look at the Node conditions instead:</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">kind</span><span class="p">:</span><span class="w"> </span>Node<span class="w">
</span><span class="w"></span><span class="k">status</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="k">conditions</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">    </span>- <span class="k">type</span><span class="p">:</span><span class="w"> </span>DiskPressure<span class="w">
</span><span class="w">      </span><span class="k">status</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;False&#34;</span><span class="w">
</span><span class="w">      </span><span class="k">reason</span><span class="p">:</span><span class="w"> </span>KubeletHasNoDiskPressure<span class="w">
</span><span class="w">      </span><span class="k">message</span><span class="p">:</span><span class="w"> </span>kubelet<span class="w"> </span>has<span class="w"> </span>no<span class="w"> </span>disk<span class="w"> </span>pressure<span class="w">
</span><span class="w">      </span><span class="k">lastHeartbeatTime</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;2019-11-17T14:18:26Z&#34;</span><span class="w">
</span><span class="w">      </span><span class="k">lastTransitionTime</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;2019-10-22T16:27:53Z&#34;</span><span class="w">
</span><span class="w">    </span>- <span class="k">type</span><span class="p">:</span><span class="w"> </span>Ready<span class="w">
</span><span class="w">      </span><span class="k">status</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;True&#34;</span><span class="w">
</span><span class="w">      </span><span class="k">reason</span><span class="p">:</span><span class="w"> </span>KubeletReady<span class="w">
</span><span class="w">      </span><span class="k">message</span><span class="p">:</span><span class="w"> </span>kubelet<span class="w"> </span>is<span class="w"> </span>posting<span class="w"> </span>ready<span class="w"> </span>status.<span class="w"> </span>AppArmor<span class="w"> </span>enabled<span class="w">
</span><span class="w">      </span><span class="k">lastHeartbeatTime</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;2019-11-17T14:18:26Z&#34;</span><span class="w">
</span><span class="w">      </span><span class="k">lastTransitionTime</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;2019-10-22T16:27:53Z&#34;</span><span class="w">
</span></code></pre></div><p>Here, the &lsquo;Ready&rsquo; condition type has an additional &lsquo;Reason&rsquo; field that
gives the user more information about the transition. The Reason field is
sometimes used by other components: for example, <code>PodReasonUnschedulable</code>
is a reason of the <code>PodSchedulable</code> condition type. This reason is set by
the kube-scheduler and is &lsquo;consumed&rsquo; by the kubelet (or the reverse, I
can&rsquo;t really tell).</p>
<p>So, Reason of another condition or Condition? If you feel that this state
might be interesting to the rest of the system, then use a proper
Condition.</p>
<p>Regarding the &lsquo;phase&rsquo; top-level field, I would recommend to offer it to
your users when the conditions alone cannot help them answer questions such
as <em>has my pod terminated?</em>.</p>
<h2 id="how-many-conditions">How many conditions?</h2>
<p>If you think that the &lsquo;Errored&rsquo; state can be useful for other components or
the user (e.g. <code>kubectl wait --for=condition=errored</code>), then add it. If you
think it is important for other components or for the user to know that
something is in progress, go ahead and add a &lsquo;InProgress&rsquo; condition.</p>
<p>Regarding the naming of condition types, here is some advice:</p>
<blockquote>
<p>(<a href="https://github.com/kubernetes/community/blob/a2cdce5/contributors/devel/sig-architecture/api-conventions.md">api-conventions</a>, July 2017) Condition types should indicate state in
the &ldquo;abnormal-true&rdquo; polarity. For example, if the condition indicates
when a policy is invalid, the &ldquo;is valid&rdquo; case is probably the norm, so
the condition should be called &ldquo;Invalid&rdquo;.</p>
</blockquote>
<p>Also, remember that these types are part of your API and you should keep in
mind that they require maintaining backwards- and forwards-compatibility.
Adding a new condition is not free: you must maintain them over time.</p>
<blockquote>
<p>(<a href="https://github.com/kubernetes/community/blob/a2cdce5/contributors/devel/sig-architecture/api-conventions.md">api-conventions</a>, July 2017) The meaning of a Condition can not be
changed arbitrarily - it becomes part of the API, and has the same
backwards- and forwards-compatibility concerns of any other part of the
API.</p>
</blockquote>
<p>Conditions are also a clean way of letting third-party components (such as
the cluster-api controller) to add their own &lsquo;named&rsquo; conditions to an
existing object, e.g. to a Pod (see <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate">pod-readiness-gate</a>):</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">Kind</span><span class="p">:</span><span class="w"> </span>Pod<span class="w">
</span><span class="w"></span><span class="k">spec</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="k">readinessGates</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">    </span>- <span class="k">conditionType</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;www.example.com/feature-1&#34;</span><span class="w">
</span><span class="w"></span><span class="k">status</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="k">conditions</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">    </span>- <span class="k">type</span><span class="p">:</span><span class="w"> </span>Ready<span class="w"> </span><span class="c"># this is a builtin PodCondition</span><span class="w">
</span><span class="w">      </span><span class="k">status</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;False&#34;</span><span class="w">
</span><span class="w">    </span>- <span class="k">type</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;www.example.com/feature-1&#34;</span><span class="w"> </span><span class="c"># an extra PodCondition</span><span class="w">
</span><span class="w">      </span><span class="k">status</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;False&#34;</span><span class="w">
</span></code></pre></div><!--
Discussion is happening here:

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Kubernetes custom controllers are awesome, CRDs are great! Still, these Conditions are confusing: is it meant for the user, and what about that &#39;phase&#39; thing?<br><br>Here is my attempt at understanding all that üòÖ<a href="https://t.co/CllGBXtd70">https://t.co/CllGBXtd70</a></p>&mdash; Ma√´l Valais (@maelvls) <a href="https://twitter.com/maelvls/status/1195058503695642627?ref_src=twsrc%5Etfw">November 14, 2019</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

-->

</div>
<a href="https://github.com/maelvls/maelvls.github.io/edit/source/content/2019/kubernetes-conditions/index.md">üìù Edit this page and propose a change!</a>
<div class="tags">










<div style="float: right;">
<p>Tags:















<a href="/tags/controller/"> controller </a>

























<a href="/tags/go/"> go </a>





















<a href="/tags/kubernetes/"> kubernetes </a>

































</div>
<div class="clearit"></div>





</div>

<script
  src="https://utteranc.es/client.js"
  repo="maelvls/maelvls.github.io"
  issue-term="pathname"
  label="üí¨"
  theme="github-light"
  crossorigin="anonymous"
  async
></script>
</div>

</main><footer>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-88710120-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</footer>
</body>
</html>
