<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2020s on maelvls dev blog</title><link>https://maelvls.dev/2020/</link><description>Recent content in 2020s on maelvls.dev</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 07 Jul 2020 16:33:55 +0200</lastBuildDate><atom:link href="https://maelvls.dev/2020/index.xml" rel="self" type="application/rss+xml"/><item><title>Understanding the Available condition of a Kubernetes deployment</title><link>https://maelvls.dev/deployment-available-condition/</link><pubDate>Tue, 07 Jul 2020 16:33:55 +0200</pubDate><guid>https://maelvls.dev/deployment-available-condition/</guid><description>
Although the Kubernetes documentation is excellent, the API reference does not document the conditions that can be found in a deployment's status. The Available condition has always eluded me!</description></item><item><title>Pull-through Docker registry on Kind clusters</title><link>https://maelvls.dev/docker-proxy-registry-kind/</link><pubDate>Fri, 03 Jul 2020 15:13:39 +0200</pubDate><guid>https://maelvls.dev/docker-proxy-registry-kind/</guid><description>
Kind offers an excellent UX to Kubernetes developers but lacks support for caching images; each time you recreate a new cluster, all the previous downloaded images are gone. In this post, I explain why the default Docker network is a trap and how to set up a registry &amp; make sure that it actually works.</description></item><item><title>Using mitmproxy to understand what kubectl does under the hood</title><link>https://maelvls.dev/mitmproxy-kubectl/</link><pubDate>Wed, 01 Jul 2020 19:17:24 +0200</pubDate><guid>https://maelvls.dev/mitmproxy-kubectl/</guid><description>
Mitmproxy is an excellent tool that helps us understand what network calls are made by programs. And kubectl is one of these interesting programs, but it uses a mutual TLS authentication which is tricky to get right.</description></item><item><title>Epic journey with statically and dynamically-linked libraries (.a, .so)</title><link>https://maelvls.dev/static-libraries-and-autoconf-hell/</link><pubDate>Sat, 30 May 2020 20:45:06 +0200</pubDate><guid>https://maelvls.dev/static-libraries-and-autoconf-hell/</guid><description>
Dynamic libraries and PIC (position-independant code) are great features of modern systems. But trying to get the right library built can become a nightmare as soon as you rely on other libraries that may or may not have these features in the first place... In this post, I detail the hacks I made to the ./configure-based build system of Yices, a C++ library.</description></item><item><title>Github Actions with a private Terraform module</title><link>https://maelvls.dev/gh-actions-with-tf-private-repo/</link><pubDate>Sat, 09 May 2020 16:02:26 +0200</pubDate><guid>https://maelvls.dev/gh-actions-with-tf-private-repo/</guid><description>
Terraform makes it easy to manage infrastructure at scale; you might want to share code between modules, and that's where it becomes tricky. In this post, I try to give some clues on how to use terraform across private Github repos.</description></item><item><title>Learning Kubernetes Controllers</title><link>https://maelvls.dev/learning-kubernetes-controllers/</link><pubDate>Wed, 22 Apr 2020 11:58:26 +0200</pubDate><guid>https://maelvls.dev/learning-kubernetes-controllers/</guid><description>
Kubernetes' extensibility is probably its biggest strength. Controllers and CRDs are all over the place. But finding the right information to begin writing a controller isn't easy due to the sheer amount of tribal knowledge scattered everywhere. Here are some links to help you start.</description></item><item><title>The Client-go Transitive Hell</title><link>https://maelvls.dev/client-go-transitive-hell/</link><pubDate>Wed, 15 Apr 2020 00:00:00 +0000</pubDate><guid>https://maelvls.dev/client-go-transitive-hell/</guid><description>
Client-go is the client library that allows anyone (including Kubernetes itself) to talk to the Kubernetes apiserver. Recently, the Kubernetes team chose to release a breaking version of client-go that adds support for context.Context, without really giving anyone notice. In this post, I detail the workaround and what that happened.</description></item><item><title>How do packets find their way back?</title><link>https://maelvls.dev/how-do-packets-come-back/</link><pubDate>Mon, 13 Apr 2020 00:00:00 +0000</pubDate><guid>https://maelvls.dev/how-do-packets-come-back/</guid><description>
In one of my previous posts, I studied how traffic flows when using Kubernetes Services. While drawing the last diagram, I did not clearly see how traffic could make its way back to the user. In this post, I focus on how packets find their way back and what makes stateless rewriting interesting.</description></item><item><title>The evolution of my home office from 2019 to 2021</title><link>https://maelvls.dev/evolution-of-my-home-office/</link><pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate><guid>https://maelvls.dev/evolution-of-my-home-office/</guid><description>
I present what hardware I have been using and what changed between 2019 and 2021!</description></item><item><title>Migrating from GKE to Civo's K3s</title><link>https://maelvls.dev/from-gke-to-civo-k3s/</link><pubDate>Sun, 22 Mar 2020 00:00:00 +0000</pubDate><guid>https://maelvls.dev/from-gke-to-civo-k3s/</guid><description>
My free trial on GKE was ending in 2 days and I had to find a way to migrate away. I decided to switch to Civo's managed K3s.</description></item><item><title>Debugging Kubernetes Networking: my kube-dns is not working!</title><link>https://maelvls.dev/debugging-kubernetes-networking/</link><pubDate>Sun, 26 Jan 2020 00:00:00 +0000</pubDate><guid>https://maelvls.dev/debugging-kubernetes-networking/</guid><description>
Some pods were unable to connect to the kube-proxy pod on one of my GKE Kubernetes clusters. This post present an in-depth investigation using tcpdump, wireshark and iptables tracing.</description></item><item><title>Avoid GKE's expensive load balancer by using hostPort</title><link>https://maelvls.dev/avoid-gke-lb-with-hostport/</link><pubDate>Mon, 20 Jan 2020 00:00:00 +0000</pubDate><guid>https://maelvls.dev/avoid-gke-lb-with-hostport/</guid><description>
I want to avoid using the expensive Google Network Load Balancer and instead do the load balancing in-cluster using akrobateo, which acts as a LoadBalancer controller.</description></item><item><title>What to do when Go ignores HTTP_PROXY for 127.0.0.1</title><link>https://maelvls.dev/go-ignores-proxy-localhost/</link><pubDate>Mon, 06 Jan 2020 00:00:00 +0000</pubDate><guid>https://maelvls.dev/go-ignores-proxy-localhost/</guid><description>
At some point, the Go team chose to disable the proxy for requests coming from localhost or 127.0.0.1. This is annoying when debugging services locally.</description></item><item><title>The Packet's-Eye View of a Kubernetes Service</title><link>https://maelvls.dev/packets-eye-kubernetes-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://maelvls.dev/packets-eye-kubernetes-service/</guid><description>
The Service and Ingress respectively brings L4 and L7 traffics to your pods. In this article, I focus on how traffic flows in and what are the interactions between the ingress controller and the service-lb controller (the thing that creates the external load balancer). I also detail how the `hostPort` approach shapes traffic.</description></item></channel></rss>