<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.64.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=author content="Ma√´l Valais"><meta name=description content><meta property="og:title" content="Everything I know about TCP"><meta property="og:description" content="How is a TCP connection uniquely identified Kill a process that is using a TCP port you need:
lsof -n -i :8001 # copy PID kill 43903 A TCP connection is identified by four things:
 source port source ip dest port dest ip  This is why there is no confusion between two requests to a web server on 80 port.
Stateful vs. Stateless Firewall This only applies to appliances in between two computers, for example a router using some kind of firewall."><meta property="og:type" content="article"><meta property="og:url" content="https://maelvls.dev/notes/tcp_ports/"><meta property="article:published_time" content="2018-02-19T00:00:00+00:00"><meta property="article:modified_time" content="2018-02-19T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Everything I know about TCP"><meta name=twitter:description content="How is a TCP connection uniquely identified Kill a process that is using a TCP port you need:
lsof -n -i :8001 # copy PID kill 43903 A TCP connection is identified by four things:
 source port source ip dest port dest ip  This is why there is no confusion between two requests to a web server on 80 port.
Stateful vs. Stateless Firewall This only applies to appliances in between two computers, for example a router using some kind of firewall."><link rel=icon type=image/png href=/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicon-16x16.png sizes=16x16><link rel=stylesheet type=text/css media=screen href=https://maelvls.dev/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://maelvls.dev/css/main.css><link rel=stylesheet type=text/css media=screen href=https://maelvls.dev/css/all.css><link rel=stylesheet type=text/css media=screen href=https://maelvls.dev/css/maelvls.css><title>Everything I know about TCP | maelvls dev blog</title></head><body><header><div id=avatar><a href=https://maelvls.dev/><img src=/img/mael.jpg alt="maelvls dev blog"></a></div><div id=titletext><h2 id=title><a href=https://maelvls.dev/>maelvls dev blog</a></h2></div><div id=title-description><p id=subtitle>Systems software engineer. I write mostly about Kubernetes and Go. <a href=/about>About</a></p><div id=social><nav><ul><li><a href=https://github.com/maelvls><i title=Github class="icons fab fa-github"></i></a></li><li><a href=https://twitter.com/maelvls><i title=Twitter class="icons fab fa-twitter"></i></a></li></ul></nav></div></div><div id=mainmenu></div></header><main><div class=post><div class=author></div><div class=post-header><div class=meta><div class=date><span class=day>19</span>
<span class=rest>Feb 2018</span></div></div><div class=matter><h1 class=title>Everything I know about TCP</h1></div></div><div class=markdown><h2 id=how-is-a-tcp-connection-uniquely-identified>How is a TCP connection uniquely identified</h2><p>Kill a process that is using a TCP port you need:</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>lsof -n -i :8001
<span class=c1># copy PID</span>
<span class=nb>kill</span> <span class=m>43903</span>
</code></pre></div><p>A TCP connection is identified by four things:</p><ul><li>source port</li><li>source ip</li><li>dest port</li><li>dest ip</li></ul><p>This is why there is no confusion between two requests to a web server on
80 port.</p><h2 id=stateful-vs-stateless-firewall>Stateful vs. Stateless Firewall</h2><p>This only applies to appliances in between two computers, for example
a router using some kind of firewall. Is it???? Is it only for NATs or
gateways?</p><div class=highlight><pre class=chroma><code class=language-plain data-lang=plain>    A -----&gt; Router -----&gt; B
</code></pre></div><p>If the router manages connection in a stateful way, here is what is going
to happen:</p><ol><li>A connects to B via a TCP connection identified by IP_A:PORT_A + IP_B:PORT_B</li><li>Router remembers the source port of A so that when B sends things back,
it can</li></ol><p>References:</p><ul><li>Using linux iptables to implement a stateless packet filtering firewall:
<a href=https://security.stackexchange.com/questions/74529>https://security.stackexchange.com/questions/74529</a></li></ul><p>Example:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>-A INPUT -p tcp -s 192.168.1.0/24 -m tcp --dport 80 -j ACCEPT
</code></pre></div><ul><li><code>-A CHAIN RULE</code> tells iptables to append this RULE at the end of this CHAIN.
A chain is identified by a name such as INPUT or OUTPUT.</li><li><code>-p TCP</code> means protocol</li><li><code>-s</code> is the source. Here, 192.168.1.0/24 means any IP adress that matches
with <code>192.*.*.*</code></li><li><code>-m TCP</code> is for extensions (see <code>man iptables-extensions</code>) but I didn&rsquo;t
find it&mldr;</li><li><code>--dport 80</code> means the destination port must be 80</li><li><code>-j ACCEPT</code> means that the target is the action &ldquo;ACCEPT&rdquo;</li></ul><p>QUESTIONS: what is the link between protocol and state?</p><h2 id=sg-vs-acls>SG vs. ACLs</h2><p>Security Groups = stateful firewall at the VM level (= iptables)
Access Control Lists = stateless firewall at the VPC level.</p><h2 id=protocol-stack>Protocol stack</h2><p>The protocol stack is the piece of software that implements (among others)
the TCP/IP layers. A socket is the internal representation of an instance
of this TCP stack. A socket is identified with a number (file descriptor in
Unix terms).</p><p>TCP connection = 2 sockets = from(ip:port) + to(ip:port)
TCP socket = internal representation of the &lsquo;from&rsquo; (ip:port)</p><h2 id=the-stack>The stack</h2><table><thead><tr><th>OSI</th><th>Lv</th><th>TCP/IP</th><th>Keywords</th><th></th></tr></thead><tbody><tr><td>Applica</td><td>L7</td><td>HTTPS</td><td>LB</td><td>Deserialized</td></tr><tr><td>Present</td><td></td><td>HTTPS</td><td></td><td>Serialized</td></tr><tr><td>Session</td><td></td><td>HTTPS</td><td></td><td></td></tr><tr><td>Transpo</td><td>L4</td><td>TCP,ICMP</td><td>Firewall</td><td>Segments</td></tr><tr><td>Network</td><td>L3</td><td>IP</td><td>Router</td><td>Packets</td></tr><tr><td>Link</td><td>L2</td><td>MAC, ARP</td><td>VLAN, Switch</td><td>Frames</td></tr><tr><td>Physic</td><td>L1</td><td></td><td></td><td>Bits</td></tr></tbody></table><p>Warning: HTTP/1.1 and such have intertwined L5, L6 and L7 responsabilities.
As an example, HTTP/1.1 carries headers that can be thought of of
application data, but the payload (data) also spans over L6 (presentation
using json for example). Session is also part of HTTP/1.1.</p><p><strong>L5-L6-L7 (application) protocols</strong> = HTTP/1.1, HTTP/2, WebSockets</p><p><strong>L6 serialization formats</strong> = protobuf, json, avro, xml</p><p><strong>VLAN</strong> = just like the good&rsquo;old ethernet between multiple equipments.
Switches aliviates some of the issues with the one-cable-for-multiple-pc
with a table (forwarding table, NOT an ARP table) that allows a one-to-one
link with less noise on each link overall.</p><p><strong>TCP</strong> = handles loss of packets using ACKs and SYN with sequence numbers.
SYN = please open a connection. ACK = acknowledge.</p><p><strong>Segments vs packets</strong> = ??</p><p>gRPC</p><h2 id=cidr-network-masks-subnets>CIDR, network masks, subnets</h2><p>10.0.2.3/16 = 16 first bits (10.0) for subnet.</p><p>The idea of subnets: inside of a subnet, we pretty much share the same
VLAN. For example, let&rsquo;s say that we have two subnets A and B.</p><table><thead><tr><th></th><th>Subnet A</th><th>Subnet B</th></tr></thead><tbody><tr><td>CIDR</td><td>10.0.1.0/24</td><td>10.0.2.0/24</td></tr><tr><td>Count</td><td>254</td><td>254</td></tr><tr><td>VLAN</td><td>VLAN1</td><td>VLAN2</td></tr></tbody></table><h3 id=link-between-subnet-l3-and-vlan-l2>Link between Subnet (L3) and VLAN (L2)</h3><p>First, let us remember that every machine in a VLAN can communicate with
each other at any time. Now, we want to control what goes from/to A and B.</p><p>In a VLAN, everything sees everything but it&rsquo;s now really helpful unless we
can use protocols like TCP. But TCP needs IPs. And IPs</p><p>A1 (10.0.1.7) &mdash;-> A2 (10.0.1.13)
Same subnet, ARP table says I know the MAC address so no need to route.</p><p>The subnet allows a machine to know what is &lsquo;internal&rsquo; traffic and what is
routed traffic.</p><ul><li>A1 &mdash;&ndash;> IP inside subnet = A1 asks which MAC has this IP using ARP.</li><li>A1 &mdash;&ndash;> IP outside subnet = NAT to the gateway (= a router). See &lsquo;Routing&rsquo;.</li></ul><h2 id=routing>Routing</h2><p>The gateway has routing tables such as</p><h2 id=aws-terms>AWS terms</h2><p>IGW = internet gateway
VPC = virtual private cloud. ne VPC is equivalent to a VLAN: everyone can
talk to everyone on L2 (MAC level).</p><p>The routing in a VPC:</p><ul><li>each subnet has an ACL (network access control list)</li><li>each EC2 has security groups (L4 stateful firewall)</li></ul></div><a href=https://github.com/maelvls/maelvls.github.io/edit/source/content/notes/tcp_ports.md>üìù Edit this page and propose a change!</a><div class=tags></div><script src=https://utteranc.es/client.js repo=maelvls/maelvls.github.io issue-term=pathname label=üí¨ theme=github-light crossorigin=anonymous async></script></div></main><footer><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-88710120-3','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></footer></body></html>