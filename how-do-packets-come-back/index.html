<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>How do packets find their way back? - maelvls dev blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="How do packets find their way back?"><meta property="og:description" content="In one of my previous posts, I studied how traffic flows when using
Kubernetes Services. While drawing the last diagram, I did not clearly
understand how traffic could make its way back to the user."><meta property="og:type" content="article"><meta property="og:url" content="https://maelvls.dev/how-do-packets-come-back/"><meta property="og:image" content="https://maelvls.dev/how-do-packets-come-back/cover-how-can-packets-come-back.png"><meta property="article:published_time" content="2020-04-13T00:00:00+00:00"><meta property="article:modified_time" content="2020-04-13T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://maelvls.dev/how-do-packets-come-back/cover-how-can-packets-come-back.png"><meta name=twitter:title content="How do packets find their way back?"><meta name=twitter:description content="In one of my previous posts, I studied how traffic flows when using
Kubernetes Services. While drawing the last diagram, I did not clearly
understand how traffic could make its way back to the user."><link rel=stylesheet type=text/css media=screen href=https://maelvls.dev/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://maelvls.dev/css/main.css><link rel=stylesheet type=text/css media=screen href=https://maelvls.dev/css/all.css><link rel=stylesheet type=text/css href=https://maelvls.dev/css/maelvls.css></head><body><div class="container wrapper"><div class=header><div class=avatar><a href=https://maelvls.dev/><img src=/img/mael.jpg alt="maelvls dev blog"></a></div><h1 class=site-title><a href=https://maelvls.dev/>maelvls dev blog</a></h1><div class=site-description><p>Systems software engineer. I write mostly about Kubernetes and Go. <a href=/about>About</a></p><nav class="nav social"><ul class=flat><li class=li-social><a href=https://github.com/maelvls><i title=Github class="icons fab fa-github"></i></a></li><li class=li-social><a href=https://twitter.com/maelvls><i title=Twitter class="icons fab fa-twitter"></i></a></li></ul></nav></div></div><div class=post><div class=author></div><div class=post-header><div class=meta><div class=date><span class=day>13</span>
<span class=rest>Apr 2020</span></div></div><div class=matter><h1 class=title>How do packets find their way back?</h1></div></div><div class=markdown><p>In this article, I will expand on the last diagram I drew for my post &ldquo;<a href=/packets-eye-of-a-service>The
Packet&rsquo;s-Eye View of a Kubernetes Service</a>".
Here is the diagram:</p><p><img alt="Packet coming from a user hitting one of the nodes directly
through DNS resolution and forwarded to the right pod" src=../packets-eye-kubernetes-service/kubernetes-traffic-with-akrobateo.svg width=70%></p><p>Notice one tiny mistake here: the port in <code>src: 1.2.3.4:80</code> is off! When
connecting to a remote host, the TCP stack picks a random ephemeral IP
above or equal 32768. The kernel calls it &ldquo;local ports&rdquo;, see
<a href=https://github.com/torvalds/linux/blob/c60174717544aa8959683d7e19d568309c3a0c65/net/ipv4/inet_hashtables.c#L739-L740>inet_hash_connect</a>,
<a href=https://github.com/torvalds/linux/blob/9c7db5004280767566e91a33445bf93aa479ef02/net/core/secure_seq.c>secure_ipv4_port_ephemeral</a>
and
<a href=https://github.com/torvalds/linux/blob/29d9f30d4ce6c7a38745a54a8cddface10013490/Documentation/networking/ip-sysctl.txt#L907-L914>ip_local_port_range</a>.
Let us fix this mistake and use the local port 32345 for example. In the
following diagram, we can see a packet coming from a user, then being
re-written by Google&rsquo;s VPC firewalls and finally coming into a VM &ldquo;node 1&rdquo;:</p><p><img alt="Packet coming from a user hitting one going through Google's VPC" src=dnat-google-vpc.svg width=90%></p><p>So, how come the packet can come back <del>and does it use conntrack</del> and
does Google&rsquo;s firewall have to remember some state?</p><blockquote><p><strong>Update 14th April:</strong> I initially thought that the conntrack kernel
module would not register anything when using DNAT.
<a href=https://networkop.co.uk/>@networkops</a> showed me that conntrack
registers the connection even for stateless DNATing.</p></blockquote><blockquote><p><a href=https://netfilter.org/documentation/HOWTO/netfilter-hacking-HOWTO-3.html#ss3.3>conntrack</a>
is a part of the netfilter suite in the Linux kernel. It is in charge of
remembering connections that are forwarded. The initial packet hits the
iptables machinery and conntrack remembers it so that further packets
don&rsquo;t need to go through iptables again. You can list the tracked
connections using the
<a href=https://manpages.debian.org/testing/conntrack/conntrack.8.en.html>conntrack(8)</a>
tool. I mention it in &ldquo;<a href=/debugging-kubernetes-networking>Debugging Kubernetes
Networking</a>".</p></blockquote><p>Let us dive a bit more and add the &ldquo;response&rdquo; packets. For the following
diagram, I used the excellent <a href=https://textik.com/>textik</a> ascii drawing
tool.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain>                     D-NAT (dest-based NAT, also called port-forwarding)

          +--------------------------------------------------------------------------+
          |   src: 90.76.45.149:32345                       src: 35.211.248.124:80   |
          |   dst: 35.211.248.124:80                        dst: 90.76.45.149:32345  |
          +------------------------------90.76.45.149--------------------------------+
                         |                 (user)                     |
                         |                                            |
          +--------------------------------------------------------------------------+
          |              |                one-to-one                  |              |
          |              v              port forwarding               |              |
          |   src: 90.76.45.149:32345          =          - src: 10.142.0.62:80      |
          | - dst: 35.211.248.124:80      no need for     + src: 35.211.248.124:80   |
          | + dst: 10.142.0.62:80         conntrack to      dst: 90.76.45.149:32345  |
          |              |                 remember!                  ^              |
          |              |                (stateless)                 |              |
          |              |                                            |              |
          +--------------|--------------35.211.248.124----------------|--------------+
                         |              (Google&#39;s VPC)                |
                         |                                            |
                         |                                            |
          +--------------|--------------------------------------------|--------------+
          |              v             userland process               |              |
          |   src: 90.76.45.149:32345      response         src: 10.142.0.62:80      |
          |   dst: 10.142.0.62:80      ----------------&gt;    dst: 90.76.45.149:32345  |
          |                                                                          |
          +-------------------------------10.142.0.62--------------------------------+
                                          (VM in VPC)
</code></pre></div><p>By reading through the diagram, we can see that the packet is re-written by
the Google&rsquo;s firewall using DNAT: the destination is replaced by a fixed
IP, the one of the VM.</p><blockquote><p>Why do I say &ldquo;packets&rdquo; but what I should really say is &ldquo;segments&rdquo;? That&rsquo;s
because I don&rsquo;t really know anyone using this strict terminology. Outside
of the kernel and TCP/IP stack implementors, who actually cares about the
L3 layer &ldquo;units&rdquo;? And I enjoy the &ldquo;packet&rdquo; word too more than &ldquo;segment&rdquo;!</p></blockquote><p>Now, why do I care about Google&rsquo;s firewalls storing state? That&rsquo;s because
if some state about a connection has to be remembered, it means it is
harder to distribute the firewall horizontally, which makes it harder to
scale.</p><p>As we can see on the diagram, the firewall does not need to remember
anything: it is just a static one-to-one relation between <code>10.142.0.62</code> and
<code>35.211.248.124</code>.</p><p>Here is what I want to remember from this post:</p><ol><li><p>Outgoing traffic from your broadband modem router has to be SNATed
(source-based NAT). The router needs to keep track of outgoing
connections using conntrack.</p></li><li><p>Incoming traffic from the Internet to a Google Cloud VM has to go
through the VPC firewall. The packet rewritting is very fast and very
scalable since it only uses DNAT, which means no need to remember
anything.</p></li><li><p>Most packet forwarding in Kubernetes also relies on stateless DNATing
(e.g. hostPorts). Note that some parts of Kubernetes rely on stateful
SNAT rewritting, for example when you use <code>policy: Cluster</code> which is the
default policy for a Service. In the above diagram, you can see that
happening:</p><img alt="Packet's source is rewritten (SNAT) because of the 'policy: Cluster' that is set in the Service." src=kubernetes-snat-cluster-ip.svg width=50%></li></ol><script src=https://utteranc.es/client.js repo=maelvls/maelvls.github.io issue-term=pathname label=ðŸ’¬ theme=github-light crossorigin=anonymous async></script></div><div class=tags><div class=taxosfloating_left><p>Tags</p></div><div class=termsfloating_right><p><a href=/tags/gcp/>gcp</a>
<a href=/tags/networking/>networking</a></p></div><div class=clearit></div></div></div></div><div class="footer wrapper"><nav class=nav><div class=footertext></div></nav></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-88710120-3','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>